// Command guix is the Guix build tool
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fsnotify/fsnotify"
	"github.com/gaarutyunov/guix/internal/cache"
	"github.com/gaarutyunov/guix/pkg/codegen"
	"github.com/gaarutyunov/guix/pkg/parser"
	"github.com/urfave/cli/v2"
)

const (
	cacheFile = ".guix/cache.json"
	guixExt   = ".gx"
)

func main() {
	app := &cli.App{
		Name:  "guix",
		Usage: "Guix build tool for Go UI components",
		Commands: []*cli.Command{
			{
				Name:  "generate",
				Usage: "Generate Go code from Guix components",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "path",
						Aliases: []string{"p"},
						Value:   ".",
						Usage:   "Target directory to scan for .gx files",
					},
					&cli.BoolFlag{
						Name:    "watch",
						Aliases: []string{"w"},
						Usage:   "Watch mode - regenerate on file changes",
					},
					&cli.BoolFlag{
						Name:  "lazy",
						Usage: "Only regenerate changed files (incremental)",
					},
					&cli.BoolFlag{
						Name:  "verbose",
						Usage: "Verbose output",
					},
					&cli.BoolFlag{
						Name:  "verbose-logs",
						Usage: "Generate verbose logging statements in code (for debugging)",
					},
				},
				Action: runGenerate,
			},
			{
				Name:  "clean",
				Usage: "Clean generated files and cache",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "path",
						Aliases: []string{"p"},
						Value:   ".",
						Usage:   "Target directory",
					},
				},
				Action: runClean,
			},
		},
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func generateHelpersFile(root string) error {
	helpersContent := `// Code generated by guix. DO NOT EDIT.

package main

import (
	"fmt"
	"syscall/js"
)

var console = js.Global().Get("console")

func log(args ...interface{}) {
	// Convert all args to strings to avoid js.ValueOf errors
	jsArgs := make([]interface{}, len(args))
	for i, arg := range args {
		jsArgs[i] = fmt.Sprint(arg)
	}
	console.Call("log", jsArgs...)
}
`
	helpersPath := filepath.Join(root, "guix_helpers_gen.go")
	if err := os.WriteFile(helpersPath, []byte(helpersContent), 0644); err != nil {
		return err
	}

	// Format with gofmt for consistency
	if err := formatFile(helpersPath); err != nil {
		log.Printf("Warning: failed to format %s: %v", helpersPath, err)
	}

	return nil
}

func runGenerate(c *cli.Context) error {
	path := c.String("path")
	watchMode := c.Bool("watch")
	lazy := c.Bool("lazy")
	verbose := c.Bool("verbose")
	verboseLogs := c.Bool("verbose-logs")

	// Load or create cache
	var genCache *cache.Cache
	var err error

	if lazy {
		genCache, err = cache.Load(filepath.Join(path, cacheFile))
		if err != nil {
			return fmt.Errorf("failed to load cache: %w", err)
		}
	}

	// Generate helpers file first (only if verbose logs are enabled)
	if verboseLogs {
		if err := generateHelpersFile(path); err != nil {
			return fmt.Errorf("failed to generate helpers: %w", err)
		}
	}

	// Generate all files initially
	if err := generateAll(path, genCache, verbose, verboseLogs); err != nil {
		return err
	}

	// Save cache if using lazy mode
	if lazy && genCache != nil {
		if err := genCache.Save(); err != nil {
			log.Printf("Warning: failed to save cache: %v", err)
		}
	}

	// Watch mode
	if watchMode {
		return watchFiles(path, genCache, verbose, verboseLogs, lazy)
	}

	return nil
}

func generateAll(root string, genCache *cache.Cache, verbose bool, verboseLogs bool) error {
	p, err := parser.New()
	if err != nil {
		return fmt.Errorf("failed to create parser: %w", err)
	}

	var count int
	err = filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip hidden directories and common exclusions
		if d.IsDir() {
			name := d.Name()
			if strings.HasPrefix(name, ".") || name == "node_modules" || name == "vendor" {
				return filepath.SkipDir
			}
			return nil
		}

		// Only process .gx files
		if !strings.HasSuffix(path, guixExt) {
			return nil
		}

		// Check if regeneration is needed
		if genCache != nil {
			needsRegen, err := genCache.NeedsRegeneration(path)
			if err != nil {
				log.Printf("Warning: failed to check cache for %s: %v", path, err)
			} else if !needsRegen {
				if verbose {
					log.Printf("Skipping %s (unchanged)", path)
				}
				return nil
			}
		}

		if err := generateFile(path, p, verbose, verboseLogs); err != nil {
			return fmt.Errorf("failed to generate %s: %w", path, err)
		}

		count++
		return nil
	})

	if err != nil {
		return err
	}

	if verbose || count > 0 {
		log.Printf("Generated %d files", count)
	}

	return nil
}

func formatFile(path string) error {
	// Read the file
	src, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	// Format with gofmt (uses go/format.Source internally)
	formatted, err := format.Source(src)
	if err != nil {
		return err
	}

	// Write back if changed
	if !bytes.Equal(src, formatted) {
		return os.WriteFile(path, formatted, 0644)
	}

	return nil
}

func generateFile(srcPath string, p *parser.Parser, verbose bool, verboseLogs bool) error {
	if verbose {
		log.Printf("Generating %s", srcPath)
	}

	// Read source file
	data, err := os.ReadFile(srcPath)
	if err != nil {
		return err
	}

	// Parse
	file, err := p.ParseBytes(srcPath, data)
	if err != nil {
		return err
	}

	// Validate
	if err := parser.Validate(file); err != nil {
		return err
	}

	// Generate Go code
	gen := codegen.New(file.Package)
	gen.SetVerbose(verboseLogs)
	output, err := gen.Generate(file)
	if err != nil {
		return err
	}

	// Write output file
	outPath := strings.TrimSuffix(srcPath, guixExt) + "_gen.go"
	if err := os.WriteFile(outPath, output, 0644); err != nil {
		return err
	}

	// Format with gofmt for consistency
	if err := formatFile(outPath); err != nil {
		log.Printf("Warning: failed to format %s: %v", outPath, err)
	}

	if verbose {
		log.Printf("Generated %s", outPath)
	}

	return nil
}

func watchFiles(root string, genCache *cache.Cache, verbose bool, verboseLogs bool, lazy bool) error {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return fmt.Errorf("failed to create watcher: %w", err)
	}
	defer func() {
		if err := watcher.Close(); err != nil {
			log.Printf("Warning: failed to close watcher: %v", err)
		}
	}()

	// Add directories to watch
	err = filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			name := d.Name()
			if strings.HasPrefix(name, ".") || name == "node_modules" || name == "vendor" {
				return filepath.SkipDir
			}

			if err := watcher.Add(path); err != nil {
				log.Printf("Warning: failed to watch %s: %v", path, err)
			}
			if verbose {
				log.Printf("Watching %s", path)
			}
		}

		return nil
	})

	if err != nil {
		return err
	}

	log.Printf("Watching for changes in %s (press Ctrl+C to stop)...", root)

	p, err := parser.New()
	if err != nil {
		return err
	}

	// Debounce timer
	var debounceTimer *time.Timer
	debounceDelay := 100 * time.Millisecond

	for {
		select {
		case event := <-watcher.Events:
			// Only handle .gx files
			if !strings.HasSuffix(event.Name, guixExt) {
				continue
			}

			// Debounce events
			if debounceTimer != nil {
				debounceTimer.Stop()
			}

			debounceTimer = time.AfterFunc(debounceDelay, func() {
				if event.Op&fsnotify.Write == fsnotify.Write ||
					event.Op&fsnotify.Create == fsnotify.Create {

					log.Printf("File changed: %s", event.Name)

					if err := generateFile(event.Name, p, verbose, verboseLogs); err != nil {
						log.Printf("Error generating %s: %v", event.Name, err)
					} else {
						log.Printf("Successfully regenerated %s", event.Name)

						// Update cache
						if lazy && genCache != nil {
							if err := genCache.UpdateHash(event.Name); err != nil {
								log.Printf("Warning: failed to update cache: %v", err)
							} else if err := genCache.Save(); err != nil {
								log.Printf("Warning: failed to save cache: %v", err)
							}
						}
					}
				} else if event.Op&fsnotify.Remove == fsnotify.Remove {
					// Remove generated file
					outPath := strings.TrimSuffix(event.Name, guixExt) + "_gen.go"
					if err := os.Remove(outPath); err != nil && !os.IsNotExist(err) {
						log.Printf("Warning: failed to remove %s: %v", outPath, err)
					} else {
						log.Printf("Removed %s", outPath)
					}

					// Remove from cache
					if lazy && genCache != nil {
						genCache.Remove(event.Name)
						if err := genCache.Save(); err != nil {
							log.Printf("Warning: failed to save cache: %v", err)
						}
					}
				}
			})

		case err := <-watcher.Errors:
			log.Printf("Watcher error: %v", err)
		}
	}
}

func runClean(c *cli.Context) error {
	path := c.String("path")

	var count int
	err := filepath.WalkDir(path, func(p string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		// Remove generated files
		if strings.HasSuffix(p, "_gen.go") {
			if err := os.Remove(p); err != nil {
				log.Printf("Warning: failed to remove %s: %v", p, err)
			} else {
				log.Printf("Removed %s", p)
				count++
			}
		}

		return nil
	})

	if err != nil {
		return err
	}

	// Remove cache
	cachePath := filepath.Join(path, cacheFile)
	if err := os.Remove(cachePath); err != nil && !os.IsNotExist(err) {
		log.Printf("Warning: failed to remove cache: %v", err)
	}

	// Remove cache directory if empty
	cacheDir := filepath.Dir(cachePath)
	_ = os.Remove(cacheDir) // Ignore error - directory might not be empty

	log.Printf("Cleaned %d generated files", count)
	return nil
}
