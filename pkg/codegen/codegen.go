// Package codegen generates Go code from Guix AST
package codegen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"strings"

	guixast "github.com/gaarutyunov/guix/pkg/ast"
)

// Generator generates Go code from Guix components
type Generator struct {
	fset       *token.FileSet
	pkg        string
	components map[string]bool // Track component names for this file
}

// New creates a new code generator
func New(pkg string) *Generator {
	return &Generator{
		fset:       token.NewFileSet(),
		pkg:        pkg,
		components: make(map[string]bool),
	}
}

// Generate generates Go code from a Guix file
func (g *Generator) Generate(file *guixast.File) ([]byte, error) {
	// First pass: collect component names
	for _, comp := range file.Components {
		g.components[comp.Name] = true
	}

	goFile := &ast.File{
		Name: ast.NewIdent(file.Package),
	}

	// Add imports
	goFile.Decls = append(goFile.Decls, g.generateImports(file))

	// Generate code for each component
	for _, comp := range file.Components {
		decls := g.generateComponent(comp)
		goFile.Decls = append(goFile.Decls, decls...)
	}

	// Format and output
	var buf bytes.Buffer

	// Write header comment manually
	buf.WriteString("// Code generated by guix. DO NOT EDIT.\n\n")

	// Format the rest of the code
	if err := format.Node(&buf, g.fset, goFile); err != nil {
		return nil, fmt.Errorf("format error: %w", err)
	}

	return buf.Bytes(), nil
}

// generateImports creates import declarations
func (g *Generator) generateImports(file *guixast.File) *ast.GenDecl {
	specs := []ast.Spec{
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"syscall/js"`,
			},
		},
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"github.com/gaarutyunov/guix/pkg/runtime"`,
			},
		},
	}

	// Only add fmt if there are channel receives in template interpolations
	// This is needed for fmt.Sprint() when displaying channel values
	needsFmt := false
	for _, comp := range file.Components {
		if g.hasChannelInterpolation(comp) {
			needsFmt = true
			break
		}
	}

	if needsFmt {
		specs = append(specs, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"fmt"`,
			},
		})
	}

	// Add user imports
	for _, imp := range file.Imports {
		specs = append(specs, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: imp.Path,
			},
		})
	}

	return &ast.GenDecl{
		Tok:    token.IMPORT,
		Lparen: 1,
		Specs:  specs,
	}
}

// generateComponent generates code for a component
func (g *Generator) generateComponent(comp *guixast.Component) []ast.Decl {
	var decls []ast.Decl

	// Generate Props struct if component has parameters
	if len(comp.Params) > 0 {
		decls = append(decls, g.generatePropsStruct(comp))
		decls = append(decls, g.generateOptionType(comp))
		decls = append(decls, g.generateOptionFuncs(comp)...)
	}

	// Generate component struct
	decls = append(decls, g.generateComponentStruct(comp))

	// Generate constructor
	decls = append(decls, g.generateConstructor(comp))

	// Check if component has channel parameters
	hasChannels := g.hasChannelParams(comp)

	// Always generate BindApp method for API consistency
	decls = append(decls, g.generateBindAppMethod(comp))

	// Generate listener methods for each channel (only if there are channels)
	if hasChannels {
		decls = append(decls, g.generateChannelListenerMethods(comp)...)
	}

	// Generate Render method
	decls = append(decls, g.generateRenderMethod(comp))

	// Generate interface compliance methods
	decls = append(decls, g.generateMountMethod(comp))
	decls = append(decls, g.generateUnmountMethod(comp))
	decls = append(decls, g.generateUpdateMethod(comp))

	return decls
}

// hasChannelParams checks if a component has any channel parameters
func (g *Generator) hasChannelParams(comp *guixast.Component) bool {
	for _, param := range comp.Params {
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			return true
		}
	}
	return false
}

// hasChannelInterpolation checks if component has template interpolations with channel receives
func (g *Generator) hasChannelInterpolation(comp *guixast.Component) bool {
	return g.bodyHasChannelInterpolation(comp.Body)
}

// bodyHasChannelInterpolation recursively checks if body contains channel interpolations
func (g *Generator) bodyHasChannelInterpolation(body *guixast.Body) bool {
	if body == nil {
		return false
	}

	for _, child := range body.Children {
		if g.nodeHasChannelInterpolation(child) {
			return true
		}
	}
	return false
}

// nodeHasChannelInterpolation checks if a node contains channel interpolations
func (g *Generator) nodeHasChannelInterpolation(node *guixast.Node) bool {
	if node == nil {
		return false
	}

	// Check template nodes for channel receive operations
	if node.Template != nil {
		for _, fragment := range node.Template.Fragments {
			if fragment.Expr != nil && fragment.Expr.ChannelOp != nil {
				return true
			}
		}
	}

	// Recursively check element children
	if node.Element != nil {
		for _, child := range node.Element.Children {
			if g.nodeHasChannelInterpolation(child) {
				return true
			}
		}
	}

	return false
}

// generatePropsStruct generates a Props struct for component parameters
func (g *Generator) generatePropsStruct(comp *guixast.Component) *ast.GenDecl {
	fields := make([]*ast.Field, len(comp.Params))

	for i, param := range comp.Params {
		fields[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(capitalize(param.Name))},
			Type:  g.typeToAST(param.Type),
		}
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(comp.Name + "Props"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{List: fields},
				},
			},
		},
	}
}

// generateOptionType generates the Option function type
func (g *Generator) generateOptionType(comp *guixast.Component) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(comp.Name + "Option"),
				Type: &ast.FuncType{
					Params: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: ast.NewIdent(comp.Name),
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateOptionFuncs generates With* option functions
func (g *Generator) generateOptionFuncs(comp *guixast.Component) []ast.Decl {
	var decls []ast.Decl

	for _, param := range comp.Params {
		funcName := "With" + capitalize(param.Name)
		optionType := comp.Name + "Option"
		fieldName := capitalize(param.Name)

		decl := &ast.FuncDecl{
			Name: ast.NewIdent(funcName),
			Type: &ast.FuncType{
				Params: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{ast.NewIdent("v")},
							Type:  g.typeToAST(param.Type),
						},
					},
				},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{Type: ast.NewIdent(optionType)},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.FuncLit{
								Type: &ast.FuncType{
									Params: &ast.FieldList{
										List: []*ast.Field{
											{
												Names: []*ast.Ident{ast.NewIdent("c")},
												Type: &ast.StarExpr{
													X: ast.NewIdent(comp.Name),
												},
											},
										},
									},
								},
								Body: &ast.BlockStmt{
									List: []ast.Stmt{
										&ast.AssignStmt{
											Lhs: []ast.Expr{
												&ast.SelectorExpr{
													X:   ast.NewIdent("c"),
													Sel: ast.NewIdent(fieldName),
												},
											},
											Tok: token.ASSIGN,
											Rhs: []ast.Expr{ast.NewIdent("v")},
										},
									},
								},
							},
						},
					},
				},
			},
		}

		decls = append(decls, decl)
	}

	return decls
}

// generateComponentStruct generates the component struct
func (g *Generator) generateComponentStruct(comp *guixast.Component) *ast.GenDecl {
	fields := []*ast.Field{
		{
			Names: []*ast.Ident{ast.NewIdent("app")},
			Type: &ast.StarExpr{
				X: &ast.SelectorExpr{
					X:   ast.NewIdent("runtime"),
					Sel: ast.NewIdent("App"),
				},
			},
		},
	}

	// Add parameter fields
	for _, param := range comp.Params {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(capitalize(param.Name))},
			Type:  g.typeToAST(param.Type),
		})

		// For channel parameters, add a current value field
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			// Extract the element type from the channel
			var elemType ast.Expr
			if param.Type.Generic != nil {
				elemType = g.typeToAST(param.Type.Generic)
			} else {
				elemType = g.typeToAST(&guixast.Type{Name: param.Type.Name})
			}

			fields = append(fields, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent("current" + capitalize(param.Name))},
				Type:  elemType,
			})
		}
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(comp.Name),
				Type: &ast.StructType{
					Fields: &ast.FieldList{List: fields},
				},
			},
		},
	}
}

// generateConstructor generates the New* constructor function
func (g *Generator) generateConstructor(comp *guixast.Component) *ast.FuncDecl {
	funcName := "New" + comp.Name
	optionType := comp.Name + "Option"

	// Build function params
	var params *ast.FieldList
	if len(comp.Params) > 0 {
		params = &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("opts")},
					Type: &ast.Ellipsis{
						Elt: ast.NewIdent(optionType),
					},
				},
			},
		}
	}

	// Build function body
	bodyStmts := []ast.Stmt{
		&ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("c")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.UnaryExpr{
					Op: token.AND,
					X: &ast.CompositeLit{
						Type: ast.NewIdent(comp.Name),
					},
				},
			},
		},
	}

	// Add option application loop only if there are parameters
	if len(comp.Params) > 0 {
		bodyStmts = append(bodyStmts, &ast.RangeStmt{
			Key:   ast.NewIdent("_"),
			Value: ast.NewIdent("opt"),
			Tok:   token.DEFINE,
			X:     ast.NewIdent("opts"),
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun:  ast.NewIdent("opt"),
							Args: []ast.Expr{ast.NewIdent("c")},
						},
					},
				},
			},
		})
	}

	bodyStmts = append(bodyStmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("c")},
	})

	return &ast.FuncDecl{
		Name: ast.NewIdent(funcName),
		Type: &ast.FuncType{
			Params: params,
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: ast.NewIdent(comp.Name),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: bodyStmts,
		},
	}
}

// generateRenderMethod generates the Render method
func (g *Generator) generateRenderMethod(comp *guixast.Component) *ast.FuncDecl {
	body := g.generateBody(comp.Body)

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Render"),
		Type: &ast.FuncType{
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.SelectorExpr{
								X:   ast.NewIdent("runtime"),
								Sel: ast.NewIdent("VNode"),
							},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{body},
				},
			},
		},
	}
}

// generateBody generates code for component body
func (g *Generator) generateBody(body *guixast.Body) ast.Expr {
	// If there are variable declarations, wrap everything in an IIFE
	if len(body.VarDecls) > 0 {
		stmts := make([]ast.Stmt, 0)

		// Add variable declarations
		for _, varDecl := range body.VarDecls {
			lhs := make([]ast.Expr, len(varDecl.Names))
			for i, name := range varDecl.Names {
				lhs[i] = ast.NewIdent(name)
			}

			rhs := make([]ast.Expr, len(varDecl.Values))
			for i, val := range varDecl.Values {
				rhs[i] = g.generateExpr(val)
			}

			stmts = append(stmts, &ast.AssignStmt{
				Lhs: lhs,
				Tok: g.assignOpToToken(varDecl.Op),
				Rhs: rhs,
			})
		}

		// Generate the UI tree
		var uiExpr ast.Expr
		if len(body.Children) == 0 {
			uiExpr = &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("runtime"),
					Sel: ast.NewIdent("Div"),
				},
			}
		} else if len(body.Children) == 1 {
			uiExpr = g.generateNode(body.Children[0])
		} else {
			// Multiple children - use Fragment
			args := make([]ast.Expr, len(body.Children))
			for i, child := range body.Children {
				args[i] = g.generateNode(child)
			}
			uiExpr = &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("runtime"),
					Sel: ast.NewIdent("Fragment"),
				},
				Args: args,
			}
		}

		// Return the UI tree
		stmts = append(stmts, &ast.ReturnStmt{
			Results: []ast.Expr{uiExpr},
		})

		// Wrap in IIFE
		return &ast.CallExpr{
			Fun: &ast.FuncLit{
				Type: &ast.FuncType{
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   ast.NewIdent("runtime"),
										Sel: ast.NewIdent("VNode"),
									},
								},
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: stmts,
				},
			},
		}
	}

	// No statements - simple case
	if len(body.Children) == 0 {
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent("Div"),
			},
		}
	}

	if len(body.Children) == 1 {
		return g.generateNode(body.Children[0])
	}

	// Multiple children - use Fragment
	args := make([]ast.Expr, len(body.Children))
	for i, child := range body.Children {
		args[i] = g.generateNode(child)
	}

	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent("Fragment"),
		},
		Args: args,
	}
}

// generateNode generates code for a node
func (g *Generator) generateNode(node *guixast.Node) ast.Expr {
	if node.Element != nil {
		return g.generateElement(node.Element)
	}

	if node.Text != nil {
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent("Text"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.STRING,
					Value: node.Text.Text,
				},
			},
		}
	}

	if node.Template != nil {
		return g.generateTemplate(node.Template)
	}

	// Default: empty div
	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent("Div"),
		},
	}
}

// Known DOM element names (common HTML elements)
var knownDOMElements = map[string]bool{
	"Div": true, "Span": true, "P": true, "A": true, "Button": true, "Input": true,
	"H1": true, "H2": true, "H3": true, "H4": true, "H5": true, "H6": true,
	"Ul": true, "Li": true, "Ol": true, "Img": true, "Form": true, "Label": true,
	"Select": true, "Option": true, "Textarea": true, "Table": true, "Tr": true,
	"Td": true, "Th": true, "Thead": true, "Tbody": true, "Tfoot": true,
	"Header": true, "Footer": true, "Nav": true, "Section": true, "Article": true,
	"Aside": true, "Main": true, "Figure": true, "Figcaption": true,
}

// generateElement generates code for an element
func (g *Generator) generateElement(elem *guixast.Element) ast.Expr {
	args := []ast.Expr{}

	// Check if this is a custom component
	// A tag is a component if:
	// 1. It's defined in the current file (in g.components map), OR
	// 2. It starts with a capital letter AND is NOT a known DOM element
	isComponent := g.components[elem.Tag] || (len(elem.Tag) > 0 && elem.Tag[0] >= 'A' && elem.Tag[0] <= 'Z' && !knownDOMElements[elem.Tag])

	// Add props as arguments
	for _, prop := range elem.Props {
		if isComponent {
			// For components, props are passed as option functions: WithProp(value)
			args = append(args, &ast.CallExpr{
				Fun:  ast.NewIdent(prop.Name),
				Args: []ast.Expr{g.generateExpr(prop.Value)},
			})
		} else {
			// For DOM elements, wrap in runtime.Prop()
			args = append(args, g.generateProp(prop))
		}
	}

	// Add children
	for _, child := range elem.Children {
		args = append(args, g.generateNode(child))
	}

	// Generate function call
	if isComponent {
		// Custom component: call NewComponent().Render()
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X: &ast.CallExpr{
					Fun:  ast.NewIdent("New" + elem.Tag),
					Args: args,
				},
				Sel: ast.NewIdent("Render"),
			},
		}
	} else {
		// DOM element: call runtime.Element()
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent(elem.Tag),
			},
			Args: args,
		}
	}
}

// generateProp generates code for a prop/event handler
func (g *Generator) generateProp(prop *guixast.Prop) ast.Expr {
	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent(prop.Name),
		},
		Args: []ast.Expr{g.generateExpr(prop.Value)},
	}
}

// generateTemplate generates code for template interpolation
func (g *Generator) generateTemplate(tmpl *guixast.Template) ast.Expr {
	if len(tmpl.Fragments) == 0 {
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent("Text"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.STRING,
					Value: `""`,
				},
			},
		}
	}

	// Build string concatenation
	var parts []ast.Expr

	for _, frag := range tmpl.Fragments {
		if frag.Text != "" {
			parts = append(parts, &ast.BasicLit{
				Kind:  token.STRING,
				Value: fmt.Sprintf(`"%s"`, frag.Text),
			})
		} else if frag.Expr != nil {
			// Convert expression to string
			parts = append(parts, &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("fmt"),
					Sel: ast.NewIdent("Sprint"),
				},
				Args: []ast.Expr{g.generateExpr(frag.Expr)},
			})
		}
	}

	// Concatenate all parts
	var result ast.Expr
	if len(parts) == 0 {
		result = &ast.BasicLit{Kind: token.STRING, Value: `""`}
	} else if len(parts) == 1 {
		result = parts[0]
	} else {
		result = parts[0]
		for i := 1; i < len(parts); i++ {
			result = &ast.BinaryExpr{
				X:  result,
				Op: token.ADD,
				Y:  parts[i],
			}
		}
	}

	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent("Text"),
		},
		Args: []ast.Expr{result},
	}
}

// generateExpr generates code for an expression
func (g *Generator) generateExpr(expr *guixast.Expr) ast.Expr {
	if expr.Literal != nil {
		return g.generateLiteral(expr.Literal)
	}

	if expr.MakeCall != nil {
		return g.generateMakeCall(expr.MakeCall)
	}

	if expr.CallOrSel != nil {
		return g.generateCallOrSelect(expr.CallOrSel)
	}

	if expr.Ident != "" {
		// Check if it's a component field reference
		return &ast.SelectorExpr{
			X:   ast.NewIdent("c"),
			Sel: ast.NewIdent(capitalize(expr.Ident)),
		}
	}

	if expr.FuncLit != nil {
		return g.generateFuncLit(expr.FuncLit)
	}

	if expr.ChannelOp != nil {
		// Instead of reading from the channel (which would block),
		// use the current value field that's updated by the channel listener
		return &ast.SelectorExpr{
			X:   ast.NewIdent("c"),
			Sel: ast.NewIdent("current" + capitalize(expr.ChannelOp.Channel)),
		}
	}

	// Default: identifier
	return ast.NewIdent("nil")
}

// generateLiteral generates code for a literal
func (g *Generator) generateLiteral(lit *guixast.Literal) ast.Expr {
	if lit.String != nil {
		return &ast.BasicLit{
			Kind:  token.STRING,
			Value: *lit.String,
		}
	}

	if lit.Number != nil {
		return &ast.BasicLit{
			Kind:  token.INT,
			Value: *lit.Number,
		}
	}

	if lit.Bool != nil {
		return ast.NewIdent(*lit.Bool)
	}

	return ast.NewIdent("nil")
}

// generateSelector generates code for a selector expression
// Example: e.Target.Value
func (g *Generator) generateSelector(sel *guixast.Selector) ast.Expr {
	// Start with the base identifier
	var result ast.Expr = ast.NewIdent(sel.Base)

	// Chain the field selectors
	for _, field := range sel.Fields {
		result = &ast.SelectorExpr{
			X:   result,
			Sel: ast.NewIdent(field),
		}
	}

	return result
}

// generateCall generates code for a function call or method call
func (g *Generator) generateCall(call *guixast.Call) ast.Expr {
	args := make([]ast.Expr, len(call.Args))
	for i, arg := range call.Args {
		args[i] = g.generateExpr(arg)
	}

	// Build the function expression from base and fields
	var fun ast.Expr = ast.NewIdent(call.Base)
	for _, field := range call.Fields {
		fun = &ast.SelectorExpr{
			X:   fun,
			Sel: ast.NewIdent(field),
		}
	}

	return &ast.CallExpr{
		Fun:  fun,
		Args: args,
	}
}

// generateMakeCall generates code for a make() function call
// Example: make(chan int, 10)
func (g *Generator) generateMakeCall(makeCall *guixast.MakeCall) ast.Expr {
	args := []ast.Expr{
		// First argument is the channel type
		&ast.ChanType{
			Dir:   ast.SEND | ast.RECV,
			Value: g.typeToAST(makeCall.ChanType),
		},
	}

	// Add size argument if present
	if makeCall.Size != nil {
		args = append(args, g.generateExpr(makeCall.Size))
	}

	return &ast.CallExpr{
		Fun:  ast.NewIdent("make"),
		Args: args,
	}
}

// generateCallOrSelect generates code for a call or selector expression
// If Args is present, generates a call. Otherwise, generates a selector.
func (g *Generator) generateCallOrSelect(cos *guixast.CallOrSelect) ast.Expr {
	// Build the base selector expression from base and fields
	var expr ast.Expr = ast.NewIdent(cos.Base)
	for _, field := range cos.Fields {
		expr = &ast.SelectorExpr{
			X:   expr,
			Sel: ast.NewIdent(field),
		}
	}

	// If there are args, wrap in a call expression
	if cos.Args != nil {
		args := make([]ast.Expr, len(cos.Args))
		for i, arg := range cos.Args {
			args[i] = g.generateExpr(arg)
		}
		return &ast.CallExpr{
			Fun:  expr,
			Args: args,
		}
	}

	// Otherwise, just return the selector expression
	return expr
}

// generateFuncLit generates code for a function literal
func (g *Generator) generateFuncLit(fn *guixast.FuncLit) ast.Expr {
	params := make([]*ast.Field, len(fn.Params))
	for i, param := range fn.Params {
		params[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(param.Name)},
			Type:  g.typeToAST(param.Type),
		}
	}

	var results *ast.FieldList
	if len(fn.Results) > 0 {
		resultFields := make([]*ast.Field, len(fn.Results))
		for i, result := range fn.Results {
			resultFields[i] = &ast.Field{
				Type: g.typeToAST(result),
			}
		}
		results = &ast.FieldList{List: resultFields}
	}

	return &ast.FuncLit{
		Type: &ast.FuncType{
			Params:  &ast.FieldList{List: params},
			Results: results,
		},
		Body: g.generateFuncBody(fn.Body),
	}
}

// generateFuncBody generates code for a function body
func (g *Generator) generateFuncBody(body *guixast.FuncBody) *ast.BlockStmt {
	stmts := make([]ast.Stmt, len(body.Statements))
	for i, stmt := range body.Statements {
		stmts[i] = g.generateStatement(stmt)
	}
	return &ast.BlockStmt{List: stmts}
}

// generateStatement generates code for a statement
func (g *Generator) generateStatement(stmt *guixast.Statement) ast.Stmt {
	if stmt.Assignment != nil {
		// Handle channel send operation
		if stmt.Assignment.Op == "<-" {
			return &ast.SendStmt{
				Chan:  ast.NewIdent(stmt.Assignment.Left),
				Value: g.generateExpr(stmt.Assignment.Right),
			}
		}

		return &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent(stmt.Assignment.Left)},
			Tok: g.assignOpToToken(stmt.Assignment.Op),
			Rhs: []ast.Expr{g.generateExpr(stmt.Assignment.Right)},
		}
	}

	if stmt.VarDecl != nil {
		lhs := make([]ast.Expr, len(stmt.VarDecl.Names))
		for i, name := range stmt.VarDecl.Names {
			lhs[i] = ast.NewIdent(name)
		}

		rhs := make([]ast.Expr, len(stmt.VarDecl.Values))
		for i, val := range stmt.VarDecl.Values {
			rhs[i] = g.generateExpr(val)
		}

		return &ast.AssignStmt{
			Lhs: lhs,
			Tok: g.assignOpToToken(stmt.VarDecl.Op),
			Rhs: rhs,
		}
	}

	if stmt.Expr != nil {
		return &ast.ExprStmt{
			X: g.generateExpr(stmt.Expr),
		}
	}

	if stmt.Return != nil {
		results := make([]ast.Expr, len(stmt.Return.Values))
		for i, val := range stmt.Return.Values {
			results[i] = g.generateExpr(val)
		}
		return &ast.ReturnStmt{Results: results}
	}

	return &ast.EmptyStmt{}
}

// typeToAST converts a Guix type to Go AST type
// Known runtime types that should be qualified with runtime package
var runtimeTypes = map[string]bool{
	"Event": true, "VNode": true, "App": true,
}

func (g *Generator) typeToAST(t *guixast.Type) ast.Expr {
	if t == nil {
		return ast.NewIdent("interface{}")
	}

	var base ast.Expr
	// Use runtime.TypeName for known runtime types
	if runtimeTypes[t.Name] {
		base = &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent(t.Name),
		}
	} else {
		base = ast.NewIdent(t.Name)
	}

	// Handle channel types
	// IsChannel && IsChan means "<-chan T" (receive-only)
	// IsChan only means "chan T" (bidirectional)
	if t.IsChannel && t.IsChan {
		base = &ast.ChanType{
			Dir:   ast.RECV,
			Value: base,
		}
	} else if t.IsChan {
		base = &ast.ChanType{
			Dir:   ast.SEND | ast.RECV,
			Value: base,
		}
	}

	if t.IsPointer {
		base = &ast.StarExpr{X: base}
	}

	return base
}

// assignOpToToken converts assignment operator string to token
func (g *Generator) assignOpToToken(op string) token.Token {
	switch op {
	case ":=":
		return token.DEFINE
	case "=":
		return token.ASSIGN
	case "+=":
		return token.ADD_ASSIGN
	case "-=":
		return token.SUB_ASSIGN
	case "*=":
		return token.MUL_ASSIGN
	case "/=":
		return token.QUO_ASSIGN
	case "<-":
		return token.ARROW
	default:
		return token.ASSIGN
	}
}

// generateMountMethod generates the Mount method
func (g *Generator) generateMountMethod(comp *guixast.Component) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Mount"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("parent")},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("js"),
							Sel: ast.NewIdent("Value"),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("runtime"),
							Sel: ast.NewIdent("Mount"),
						},
						Args: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("Render"),
								},
							},
							ast.NewIdent("parent"),
						},
					},
				},
			},
		},
	}
}

// generateUnmountMethod generates the Unmount method
func (g *Generator) generateUnmountMethod(comp *guixast.Component) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Unmount"),
		Type: &ast.FuncType{},
		Body: &ast.BlockStmt{},
	}
}

// generateUpdateMethod generates the Update method
func (g *Generator) generateUpdateMethod(comp *guixast.Component) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Update"),
		Type: &ast.FuncType{},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X: &ast.SelectorExpr{
							X:   ast.NewIdent("c"),
							Sel: ast.NewIdent("app"),
						},
						Op: token.NEQ,
						Y:  ast.NewIdent("nil"),
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ExprStmt{
								X: &ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("c"),
											Sel: ast.NewIdent("app"),
										},
										Sel: ast.NewIdent("Update"),
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateBindAppMethod generates the BindApp method for components with channels
func (g *Generator) generateBindAppMethod(comp *guixast.Component) *ast.FuncDecl {
	stmts := []ast.Stmt{
		// c.app = app
		&ast.AssignStmt{
			Lhs: []ast.Expr{
				&ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent("app"),
				},
			},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{ast.NewIdent("app")},
		},
	}

	// For each channel parameter, start a listener
	for _, param := range comp.Params {
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			// if c.ChannelName != nil { c.startChannelNameListener() }
			stmts = append(stmts, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X: &ast.SelectorExpr{
						X:   ast.NewIdent("c"),
						Sel: ast.NewIdent(capitalize(param.Name)),
					},
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("start" + capitalize(param.Name) + "Listener"),
								},
							},
						},
					},
				},
			})
		}
	}

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("BindApp"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("app")},
						Type: &ast.StarExpr{
							X: &ast.SelectorExpr{
								X:   ast.NewIdent("runtime"),
								Sel: ast.NewIdent("App"),
							},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}
}

// generateChannelListenerMethods generates listener methods for each channel parameter
func (g *Generator) generateChannelListenerMethods(comp *guixast.Component) []ast.Decl {
	var decls []ast.Decl

	for _, param := range comp.Params {
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			// Generate: func (c *Component) startChannelNameListener() { go func() { for val := range c.ChannelName { c.currentChannelName = val; c.app.Update() } }() }
			decls = append(decls, &ast.FuncDecl{
				Recv: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{ast.NewIdent("c")},
							Type: &ast.StarExpr{
								X: ast.NewIdent(comp.Name),
							},
						},
					},
				},
				Name: ast.NewIdent("start" + capitalize(param.Name) + "Listener"),
				Type: &ast.FuncType{},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						// go func() { ... }()
						&ast.GoStmt{
							Call: &ast.CallExpr{
								Fun: &ast.FuncLit{
									Type: &ast.FuncType{},
									Body: &ast.BlockStmt{
										List: []ast.Stmt{
											// for val := range c.ChannelName { ... }
											&ast.RangeStmt{
												Key:   ast.NewIdent("val"),
												Value: nil,
												Tok:   token.DEFINE,
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("c"),
													Sel: ast.NewIdent(capitalize(param.Name)),
												},
												Body: &ast.BlockStmt{
													List: []ast.Stmt{
														// c.currentChannelName = val
														&ast.AssignStmt{
															Lhs: []ast.Expr{
																&ast.SelectorExpr{
																	X:   ast.NewIdent("c"),
																	Sel: ast.NewIdent("current" + capitalize(param.Name)),
																},
															},
															Tok: token.ASSIGN,
															Rhs: []ast.Expr{ast.NewIdent("val")},
														},
														// if c.app != nil { c.app.Update() }
														&ast.IfStmt{
															Cond: &ast.BinaryExpr{
																X: &ast.SelectorExpr{
																	X:   ast.NewIdent("c"),
																	Sel: ast.NewIdent("app"),
																},
																Op: token.NEQ,
																Y:  ast.NewIdent("nil"),
															},
															Body: &ast.BlockStmt{
																List: []ast.Stmt{
																	&ast.ExprStmt{
																		X: &ast.CallExpr{
																			Fun: &ast.SelectorExpr{
																				X: &ast.SelectorExpr{
																					X:   ast.NewIdent("c"),
																					Sel: ast.NewIdent("app"),
																				},
																				Sel: ast.NewIdent("Update"),
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			})
		}
	}

	return decls
}

// Helper functions

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
