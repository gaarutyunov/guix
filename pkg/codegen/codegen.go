// Package codegen generates Go code from Guix AST
package codegen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"strings"

	guixast "github.com/gaarutyunov/guix/pkg/ast"
)

// childComponentInfo holds information about a child component instance
type childComponentInfo struct {
	varName       string
	componentType string
	element       *guixast.Element // The element with props
}

// Generator generates Go code from Guix components
// It implements the Visitor interface to traverse the Guix AST
type Generator struct {
	guixast.BaseVisitor                                          // Embed BaseVisitor for default implementations
	fset                *token.FileSet
	pkg                 string
	components          map[string]bool                          // Track component names for this file
	hoistedVars         map[string]bool                          // Track hoisted variable names in current component
	hoistedComponentMap map[*guixast.Element]*childComponentInfo // Map elements to their hoisted component info
	currentCompBody     *guixast.Body                            // Current component body being generated
	currentComp         *guixast.Component                       // Current component being generated
	componentParams     map[string]bool                          // Track current component's parameter names
	channelReceiveVars  map[string]string                        // Map local var names to channel names (e.g., "currentState" -> "StateChannel")
	verbose             bool                                     // Generate verbose logging statements

	// Result accumulation for visitor pattern
	generatedDecls      []ast.Decl                               // Accumulated declarations during traversal
}

// New creates a new code generator
func New(pkg string) *Generator {
	return &Generator{
		fset:       token.NewFileSet(),
		pkg:        pkg,
		components: make(map[string]bool),
		verbose:    false, // Verbose logging disabled by default
	}
}

// SetVerbose enables or disables verbose logging in generated code
func (g *Generator) SetVerbose(verbose bool) {
	g.verbose = verbose
}

// isComponentFunc checks if a function is a UI component (returns Component interface)
// or just a regular helper function
func (g *Generator) isComponentFunc(comp *guixast.Component) bool {
	// If it has no return type, it's a regular function
	if len(comp.Results) == 0 {
		return false
	}

	// Check if any result is named "Component" (the interface)
	for _, result := range comp.Results {
		if result.Name == "Component" {
			return true
		}
	}

	return false
}

// Generate generates Go code from a Guix file
func (g *Generator) Generate(file *guixast.File) ([]byte, error) {
	// First pass: collect component names (only for actual components, not helper functions)
	for _, comp := range file.Components {
		if g.isComponentFunc(comp) {
			g.components[comp.Name] = true
		}
	}

	goFile := &ast.File{
		Name: ast.NewIdent(file.Package),
	}

	// Add imports
	goFile.Decls = append(goFile.Decls, g.generateImports(file))

	// Generate type definitions
	for _, typeDef := range file.Types {
		goFile.Decls = append(goFile.Decls, g.generateTypeDef(typeDef))
	}

	// Generate code for each component/function
	for _, comp := range file.Components {
		var decls []ast.Decl
		if g.isComponentFunc(comp) {
			// Generate full component with struct, methods, etc.
			decls = g.generateComponent(comp)
		} else {
			// Generate simple function
			decls = []ast.Decl{g.generateFunction(comp)}
		}
		goFile.Decls = append(goFile.Decls, decls...)
	}

	// Format and output
	var buf bytes.Buffer

	// Write build tags for WASM target
	buf.WriteString("//go:build js && wasm\n")
	buf.WriteString("// +build js,wasm\n\n")

	// Write header comment manually
	buf.WriteString("// Code generated by guix. DO NOT EDIT.\n\n")

	// Format the rest of the code
	if err := format.Node(&buf, g.fset, goFile); err != nil {
		return nil, fmt.Errorf("format error: %w", err)
	}

	return buf.Bytes(), nil
}

// generateImports creates import declarations
func (g *Generator) generateImports(file *guixast.File) *ast.GenDecl {
	specs := []ast.Spec{
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"syscall/js"`,
			},
		},
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"github.com/gaarutyunov/guix/pkg/runtime"`,
			},
		},
	}

	// Only add fmt if there are template interpolations with expressions
	// This is needed for fmt.Sprint() when displaying values in templates like `{value}` or `{<-channel}`
	needsFmt := false
	for _, comp := range file.Components {
		if g.hasChannelInterpolation(comp) {
			needsFmt = true
			break
		}
	}

	if needsFmt {
		specs = append(specs, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"fmt"`,
			},
		})
	}

	// Add user imports
	for _, imp := range file.Imports {
		specs = append(specs, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: imp.Path,
			},
		})
	}

	return &ast.GenDecl{
		Tok:    token.IMPORT,
		Lparen: 1,
		Specs:  specs,
	}
}

// generateTypeDef generates code for a type definition
func (g *Generator) generateTypeDef(typeDef *guixast.TypeDef) *ast.GenDecl {
	if typeDef.Struct != nil {
		// Generate struct type
		fields := make([]*ast.Field, len(typeDef.Struct.Fields))
		for i, field := range typeDef.Struct.Fields {
			fields[i] = &ast.Field{
				Names: []*ast.Ident{ast.NewIdent(field.Name)},
				Type:  g.typeToAST(field.Type),
			}
		}

		return &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: ast.NewIdent(typeDef.Name),
					Type: &ast.StructType{
						Fields: &ast.FieldList{List: fields},
					},
				},
			},
		}
	}

	// Default: empty type (shouldn't happen)
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(typeDef.Name),
				Type: ast.NewIdent("interface{}"),
			},
		},
	}
}

// generateFunction generates code for a regular helper function (not a UI component)
func (g *Generator) generateFunction(comp *guixast.Component) *ast.FuncDecl {
	// Set up context
	g.hoistedVars = make(map[string]bool)
	g.currentCompBody = comp.Body

	// Generate parameters
	params := make([]*ast.Field, len(comp.Params))
	for i, param := range comp.Params {
		params[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(param.Name)},
			Type:  g.typeToAST(param.Type),
		}
	}

	// Generate result types
	var results *ast.FieldList
	if len(comp.Results) > 0 {
		resultFields := make([]*ast.Field, len(comp.Results))
		for i, result := range comp.Results {
			resultFields[i] = &ast.Field{
				Type: g.typeToAST(result),
			}
		}
		results = &ast.FieldList{List: resultFields}
	}

	// Generate function body as statements
	bodyStmts := g.generateFunctionBodyStmts(comp.Body)

	return &ast.FuncDecl{
		Name: ast.NewIdent(comp.Name),
		Type: &ast.FuncType{
			Params:  &ast.FieldList{List: params},
			Results: results,
		},
		Body: &ast.BlockStmt{
			List: bodyStmts,
		},
	}
}

// generateFunctionBodyStmts generates statements for a regular function body
func (g *Generator) generateFunctionBodyStmts(body *guixast.Body) []ast.Stmt {
	stmts := make([]ast.Stmt, 0)

	// Add variable declarations
	for _, varDecl := range body.VarDecls {
		lhs := make([]ast.Expr, len(varDecl.Names))
		for i, name := range varDecl.Names {
			lhs[i] = ast.NewIdent(name)
		}

		rhs := make([]ast.Expr, len(varDecl.Values))
		for i, val := range varDecl.Values {
			rhs[i] = g.generateExpr(val)
		}

		stmts = append(stmts, &ast.AssignStmt{
			Lhs: lhs,
			Tok: g.assignOpToToken(varDecl.Op),
			Rhs: rhs,
		})
	}

	// Add statements
	for _, stmt := range body.Statements {
		stmts = append(stmts, g.generateBodyStatement(stmt))
	}

	// Process children as statements (should be minimal for regular functions)
	for _, child := range body.Children {
		if child.ExprStmt != nil {
			stmts = append(stmts, &ast.ExprStmt{
				X: g.generateCallOrSelect(child.ExprStmt.Expr),
			})
		}
	}

	return stmts
}

// generateComponent generates code for a component
func (g *Generator) generateComponent(comp *guixast.Component) []ast.Decl {
	var decls []ast.Decl

	// Set current component context
	g.currentComp = comp
	g.componentParams = make(map[string]bool)
	for _, param := range comp.Params {
		g.componentParams[param.Name] = true
	}

	// Reset hoisted component map for this component
	g.hoistedComponentMap = make(map[*guixast.Element]*childComponentInfo)

	// Generate Props struct if component has parameters
	if len(comp.Params) > 0 {
		decls = append(decls, g.generatePropsStruct(comp))
		decls = append(decls, g.generateOptionType(comp))
		decls = append(decls, g.generateOptionFuncs(comp)...)
	}

	// Generate component struct
	decls = append(decls, g.generateComponentStruct(comp))

	// Generate constructor
	decls = append(decls, g.generateConstructor(comp))

	// Check if component has channel parameters
	hasChannels := g.hasChannelParams(comp)

	// Always generate BindApp method for API consistency
	decls = append(decls, g.generateBindAppMethod(comp))

	// Generate listener methods for each channel (only if there are channels)
	if hasChannels {
		decls = append(decls, g.generateChannelListenerMethods(comp)...)
	}

	// Generate Render method
	decls = append(decls, g.generateRenderMethod(comp))

	// Generate interface compliance methods
	decls = append(decls, g.generateMountMethod(comp))
	decls = append(decls, g.generateUnmountMethod(comp))
	decls = append(decls, g.generateUpdateMethod(comp))

	return decls
}

// hasChannelParams checks if a component has any channel parameters
func (g *Generator) hasChannelParams(comp *guixast.Component) bool {
	for _, param := range comp.Params {
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			return true
		}
	}
	return false
}

// hasChannelInterpolation checks if component has template interpolations
// (renamed for compatibility but now checks for any interpolation, not just channels)
func (g *Generator) hasChannelInterpolation(comp *guixast.Component) bool {
	return g.bodyHasTemplateInterpolation(comp.Body)
}

// bodyHasTemplateInterpolation recursively checks if body contains template interpolations
func (g *Generator) bodyHasTemplateInterpolation(body *guixast.Body) bool {
	if body == nil {
		return false
	}

	for _, child := range body.Children {
		if g.nodeHasTemplateInterpolation(child) {
			return true
		}
	}
	return false
}

// nodeHasTemplateInterpolation checks if a node contains template interpolations
func (g *Generator) nodeHasTemplateInterpolation(node *guixast.Node) bool {
	if node == nil {
		return false
	}

	// Check template nodes for any expression interpolation
	// Any expression in a template like `{value}` or `{<-channel}` uses fmt.Sprint
	if node.Template != nil {
		for _, fragment := range node.Template.Fragments {
			if fragment.Expr != nil {
				return true
			}
		}
	}

	// Recursively check element children
	if node.Element != nil {
		for _, child := range node.Element.Children {
			if g.nodeHasTemplateInterpolation(child) {
				return true
			}
		}
	}

	return false
}

// collectChildComponents recursively collects child component usages from nodes
func (g *Generator) collectChildComponents(nodes []*guixast.Node) []*childComponentInfo {
	var childComponents []*childComponentInfo
	g.collectChildComponentsFromNodes(nodes, &childComponents)
	return childComponents
}

func (g *Generator) collectChildComponentsFromNodes(nodes []*guixast.Node, result *[]*childComponentInfo) {
	for _, node := range nodes {
		if node.Element != nil {
			elem := node.Element
			// Check if this is a component (capitalized tag name)
			isComponent := g.components[elem.Tag] || (len(elem.Tag) > 0 && elem.Tag[0] >= 'A' && elem.Tag[0] <= 'Z' && !knownDOMElements[elem.Tag])

			if isComponent {
				// Generate a variable name for this component instance
				varName := strings.ToLower(elem.Tag[:1]) + elem.Tag[1:] + "Instance"
				childInfo := &childComponentInfo{
					varName:       varName,
					componentType: elem.Tag,
					element:       elem,
				}
				*result = append(*result, childInfo)
				// Add to map for quick lookup during render generation
				g.hoistedComponentMap[elem] = childInfo
			}

			// Recursively check children
			g.collectChildComponentsFromNodes(elem.Children, result)
		}
	}
}

// generatePropsStruct generates a Props struct for component parameters
func (g *Generator) generatePropsStruct(comp *guixast.Component) *ast.GenDecl {
	fields := make([]*ast.Field, len(comp.Params))

	for i, param := range comp.Params {
		fields[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(capitalize(param.Name))},
			Type:  g.typeToAST(param.Type),
		}
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(comp.Name + "Props"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{List: fields},
				},
			},
		},
	}
}

// generateOptionType generates the Option function type
func (g *Generator) generateOptionType(comp *guixast.Component) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(comp.Name + "Option"),
				Type: &ast.FuncType{
					Params: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: ast.NewIdent(comp.Name),
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateOptionFuncs generates With* option functions
func (g *Generator) generateOptionFuncs(comp *guixast.Component) []ast.Decl {
	var decls []ast.Decl

	for _, param := range comp.Params {
		funcName := "With" + capitalize(param.Name)
		optionType := comp.Name + "Option"
		fieldName := capitalize(param.Name)

		decl := &ast.FuncDecl{
			Name: ast.NewIdent(funcName),
			Type: &ast.FuncType{
				Params: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{ast.NewIdent("v")},
							Type:  g.typeToAST(param.Type),
						},
					},
				},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{Type: ast.NewIdent(optionType)},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.FuncLit{
								Type: &ast.FuncType{
									Params: &ast.FieldList{
										List: []*ast.Field{
											{
												Names: []*ast.Ident{ast.NewIdent("c")},
												Type: &ast.StarExpr{
													X: ast.NewIdent(comp.Name),
												},
											},
										},
									},
								},
								Body: &ast.BlockStmt{
									List: []ast.Stmt{
										&ast.AssignStmt{
											Lhs: []ast.Expr{
												&ast.SelectorExpr{
													X:   ast.NewIdent("c"),
													Sel: ast.NewIdent(fieldName),
												},
											},
											Tok: token.ASSIGN,
											Rhs: []ast.Expr{ast.NewIdent("v")},
										},
									},
								},
							},
						},
					},
				},
			},
		}

		decls = append(decls, decl)
	}

	return decls
}

// generateComponentStruct generates the component struct
func (g *Generator) generateComponentStruct(comp *guixast.Component) *ast.GenDecl {
	fields := []*ast.Field{
		{
			Names: []*ast.Ident{ast.NewIdent("app")},
			Type: &ast.StarExpr{
				X: &ast.SelectorExpr{
					X:   ast.NewIdent("runtime"),
					Sel: ast.NewIdent("App"),
				},
			},
		},
	}

	// Add parameter fields
	for _, param := range comp.Params {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(capitalize(param.Name))},
			Type:  g.typeToAST(param.Type),
		})

		// For channel parameters, add a current value field
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			// Extract the element type from the channel
			var elemType ast.Expr
			if param.Type.Generic != nil {
				elemType = g.typeToAST(param.Type.Generic)
			} else {
				elemType = g.typeToAST(&guixast.Type{Name: param.Type.Name})
			}

			fields = append(fields, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent("current" + capitalize(param.Name))},
				Type:  elemType,
			})
		}
	}

	// Add VarDecl fields from component body (for stateful variables)
	// This ensures channels and components persist across renders
	if comp.Body != nil {
		for _, varDecl := range comp.Body.VarDecls {
			for i, name := range varDecl.Names {
				if i < len(varDecl.Values) {
					// Determine the type from the value expression
					varType := g.inferTypeFromExpr(varDecl.Values[i])
					if varType != nil {
						fields = append(fields, &ast.Field{
							Names: []*ast.Ident{ast.NewIdent(name)},
							Type:  varType,
						})
					}
				}
			}
		}

		// Add child component instance fields
		// Collect child components from the template
		childComponents := g.collectChildComponents(comp.Body.Children)
		for _, childInfo := range childComponents {
			fields = append(fields, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent(childInfo.varName)},
				Type: &ast.StarExpr{
					X: ast.NewIdent(childInfo.componentType),
				},
			})
		}
	}

	// Add listenersStarted flag if component has channel parameters
	// This makes BindApp idempotent to prevent multiple goroutine leaks
	if g.hasChannelParams(comp) {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent("listenersStarted")},
			Type:  ast.NewIdent("bool"),
		})
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(comp.Name),
				Type: &ast.StructType{
					Fields: &ast.FieldList{List: fields},
				},
			},
		},
	}
}

// inferTypeFromExpr infers the Go AST type from a Guix expression
func (g *Generator) inferTypeFromExpr(expr *guixast.Expr) ast.Expr {
	if expr == nil || expr.Left == nil {
		return nil
	}

	// Handle make(chan Type, size)
	if expr.Left.MakeCall != nil {
		return &ast.ChanType{
			Dir:   ast.SEND | ast.RECV,
			Value: g.typeToAST(expr.Left.MakeCall.ChanType),
		}
	}

	// For other expression types, we can't easily infer the type without more context
	// For now, return nil and skip adding the field (will remain as local var)
	// TODO: Add type inference for other expressions if needed
	return nil
}

// generateConstructor generates the New* constructor function
func (g *Generator) generateConstructor(comp *guixast.Component) *ast.FuncDecl {
	funcName := "New" + comp.Name
	optionType := comp.Name + "Option"

	// Build function params
	var params *ast.FieldList
	if len(comp.Params) > 0 {
		params = &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("opts")},
					Type: &ast.Ellipsis{
						Elt: ast.NewIdent(optionType),
					},
				},
			},
		}
	}

	// Build function body
	bodyStmts := []ast.Stmt{
		&ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("c")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.UnaryExpr{
					Op: token.AND,
					X: &ast.CompositeLit{
						Type: ast.NewIdent(comp.Name),
					},
				},
			},
		},
	}

	// Add option application loop only if there are parameters
	if len(comp.Params) > 0 {
		bodyStmts = append(bodyStmts, &ast.RangeStmt{
			Key:   ast.NewIdent("_"),
			Value: ast.NewIdent("opt"),
			Tok:   token.DEFINE,
			X:     ast.NewIdent("opts"),
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun:  ast.NewIdent("opt"),
							Args: []ast.Expr{ast.NewIdent("c")},
						},
					},
				},
			},
		})
	}

	// Initialize hoisted variables (like channels) in constructor
	if comp.Body != nil {
		// Set up hoisted vars map for expression generation
		g.hoistedVars = make(map[string]bool)
		g.currentCompBody = comp.Body
		for _, varDecl := range comp.Body.VarDecls {
			if len(varDecl.Names) == 1 && len(varDecl.Values) == 1 &&
				g.inferTypeFromExpr(varDecl.Values[0]) != nil {
				g.hoistedVars[varDecl.Names[0]] = true
			}
		}

		for _, varDecl := range comp.Body.VarDecls {
			// Only initialize single-variable declarations with inferable types
			if len(varDecl.Names) == 1 && len(varDecl.Values) == 1 {
				varType := g.inferTypeFromExpr(varDecl.Values[0])
				if varType != nil {
					// Generate: c.varName = make(chan Type, size)
					bodyStmts = append(bodyStmts, &ast.AssignStmt{
						Lhs: []ast.Expr{&ast.SelectorExpr{
							X:   ast.NewIdent("c"),
							Sel: ast.NewIdent(varDecl.Names[0]),
						}},
						Tok: token.ASSIGN,
						Rhs: []ast.Expr{g.generateExpr(varDecl.Values[0])},
					})
				} else if varDecl.Values[0].Left != nil && varDecl.Values[0].Left.ChannelOp != nil {
					// This is a channel receive: varName := <-channelName
					channelName := varDecl.Values[0].Left.ChannelOp.Channel

					// Check if the channel is a component parameter
					isParam := false
					for _, param := range comp.Params {
						if param.Name == channelName {
							isParam = true
							break
						}
					}

					if isParam {
						// Generate: if c.ChannelName != nil { c.currentChannelName = <-c.ChannelName }
						// The field "currentChannelName" was already created in generateComponentStruct

						// Build the channel read statements (with optional logging)
						channelReadStmts := []ast.Stmt{}

						// Add debug log if verbose
						if g.verbose {
							channelReadStmts = append(channelReadStmts, &ast.ExprStmt{
								X: &ast.CallExpr{
									Fun: ast.NewIdent("log"),
									Args: []ast.Expr{
										&ast.BasicLit{
											Kind:  token.STRING,
											Value: fmt.Sprintf(`"%s: About to read initial state from %s"`, comp.Name, capitalize(channelName)),
										},
									},
								},
							})
						}

						// Add the channel read
						channelReadStmts = append(channelReadStmts, &ast.AssignStmt{
							Lhs: []ast.Expr{
								&ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("current" + capitalize(channelName)),
								},
							},
							Tok: token.ASSIGN,
							Rhs: []ast.Expr{
								&ast.UnaryExpr{
									Op: token.ARROW,
									X: &ast.SelectorExpr{
										X:   ast.NewIdent("c"),
										Sel: ast.NewIdent(capitalize(channelName)),
									},
								},
							},
						})

						// Add debug log if verbose
						if g.verbose {
							channelReadStmts = append(channelReadStmts, &ast.ExprStmt{
								X: &ast.CallExpr{
									Fun: ast.NewIdent("log"),
									Args: []ast.Expr{
										&ast.BasicLit{
											Kind:  token.STRING,
											Value: fmt.Sprintf(`"%s: Received initial state from channel"`, comp.Name),
										},
									},
								},
							})
						}

						bodyStmts = append(bodyStmts, &ast.IfStmt{
							Cond: &ast.BinaryExpr{
								X: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent(capitalize(channelName)),
								},
								Op: token.NEQ,
								Y:  ast.NewIdent("nil"),
							},
							Body: &ast.BlockStmt{
								List: channelReadStmts,
							},
						})
					}
				}
			}
		}

		// Process additional statements (like channel sends)
		for _, stmt := range comp.Body.Statements {
			if stmt.Assignment != nil && stmt.Assignment.Op == "<-" {
				// Generate channel send: c.varName <- value
				lhs := stmt.Assignment.Left
				if g.hoistedVars[lhs] {
					// This is a hoisted variable, use c.varName
					bodyStmts = append(bodyStmts, &ast.SendStmt{
						Chan: &ast.SelectorExpr{
							X:   ast.NewIdent("c"),
							Sel: ast.NewIdent(lhs),
						},
						Value: g.generateExpr(stmt.Assignment.Right),
					})
				}
			} else if stmt.Assignment != nil && (stmt.Assignment.Op == ":=" || stmt.Assignment.Op == "=") {
				// Check if this is a channel receive assignment: varName := <-channelName
				if stmt.Assignment.Right != nil && stmt.Assignment.Right.Left != nil &&
					stmt.Assignment.Right.Left.ChannelOp != nil {
					channelName := stmt.Assignment.Right.Left.ChannelOp.Channel

					// Check if the channel is a component parameter
					isParam := false
					for _, param := range comp.Params {
						if param.Name == channelName {
							isParam = true
							break
						}
					}

					if isParam {
						// Generate: if c.ChannelName != nil { c.currentChannelName = <-c.ChannelName }
						// The field "currentChannelName" was already created in generateComponentStruct

						// Build the channel read statements (with optional logging)
						channelReadStmts := []ast.Stmt{}

						// Add debug log if verbose
						if g.verbose {
							channelReadStmts = append(channelReadStmts, &ast.ExprStmt{
								X: &ast.CallExpr{
									Fun: ast.NewIdent("log"),
									Args: []ast.Expr{
										&ast.BasicLit{
											Kind:  token.STRING,
											Value: fmt.Sprintf(`"%s: About to read initial state from %s"`, comp.Name, capitalize(channelName)),
										},
									},
								},
							})
						}

						// Add the channel read
						channelReadStmts = append(channelReadStmts, &ast.AssignStmt{
							Lhs: []ast.Expr{
								&ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("current" + capitalize(channelName)),
								},
							},
							Tok: token.ASSIGN,
							Rhs: []ast.Expr{
								&ast.UnaryExpr{
									Op: token.ARROW,
									X: &ast.SelectorExpr{
										X:   ast.NewIdent("c"),
										Sel: ast.NewIdent(capitalize(channelName)),
									},
								},
							},
						})

						// Add debug log if verbose
						if g.verbose {
							channelReadStmts = append(channelReadStmts, &ast.ExprStmt{
								X: &ast.CallExpr{
									Fun: ast.NewIdent("log"),
									Args: []ast.Expr{
										&ast.BasicLit{
											Kind:  token.STRING,
											Value: fmt.Sprintf(`"%s: Received initial state from channel"`, comp.Name),
										},
									},
								},
							})
						}

						bodyStmts = append(bodyStmts, &ast.IfStmt{
							Cond: &ast.BinaryExpr{
								X: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent(capitalize(channelName)),
								},
								Op: token.NEQ,
								Y:  ast.NewIdent("nil"),
							},
							Body: &ast.BlockStmt{
								List: channelReadStmts,
							},
						})
					}
				}
			}
		}

		// Initialize child component instances
		childComponents := g.collectChildComponents(comp.Body.Children)
		for _, childInfo := range childComponents {
			// Generate option calls from props
			optionCalls := []ast.Expr{}
			for _, prop := range childInfo.element.Props {
				optionCalls = append(optionCalls, &ast.CallExpr{
					Fun:  ast.NewIdent(prop.Name),
					Args: []ast.Expr{g.generateExpr(prop.Value)},
				})
			}

			// Generate: c.childInstance = NewChildComponent(options...)
			bodyStmts = append(bodyStmts, &ast.AssignStmt{
				Lhs: []ast.Expr{&ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent(childInfo.varName),
				}},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun:  ast.NewIdent("New" + childInfo.componentType),
						Args: optionCalls,
					},
				},
			})
		}
	}

	bodyStmts = append(bodyStmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("c")},
	})

	return &ast.FuncDecl{
		Name: ast.NewIdent(funcName),
		Type: &ast.FuncType{
			Params: params,
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: ast.NewIdent(comp.Name),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: bodyStmts,
		},
	}
}

// generateRenderMethod generates the Render method
func (g *Generator) generateRenderMethod(comp *guixast.Component) *ast.FuncDecl {
	// Set up context for hoisted variable tracking
	g.hoistedVars = make(map[string]bool)
	g.channelReceiveVars = make(map[string]string)
	g.currentCompBody = comp.Body

	// Collect hoisted variable names and channel receive variables
	if comp.Body != nil {
		for _, varDecl := range comp.Body.VarDecls {
			if len(varDecl.Names) == 1 && len(varDecl.Values) == 1 {
				if g.inferTypeFromExpr(varDecl.Values[0]) != nil {
					g.hoistedVars[varDecl.Names[0]] = true
				} else if varDecl.Values[0].Left != nil && varDecl.Values[0].Left.ChannelOp != nil {
					// Track channel receive: currentState := <-stateChannel
					channelName := varDecl.Values[0].Left.ChannelOp.Channel
					g.channelReceiveVars[varDecl.Names[0]] = capitalize(channelName)
				}
			}
		}
	}

	// Populate hoisted component map for this component
	if comp.Body != nil {
		g.collectChildComponents(comp.Body.Children)
	}

	body := g.generateBody(comp.Body)

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Render"),
		Type: &ast.FuncType{
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.SelectorExpr{
								X:   ast.NewIdent("runtime"),
								Sel: ast.NewIdent("VNode"),
							},
						},
					},
				},
			},
		},
		Body: func() *ast.BlockStmt {
			stmts := []ast.Stmt{}

			// Add verbose logging if enabled
			if g.verbose {
				stmts = append(stmts, &ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: ast.NewIdent("log"),
						Args: []ast.Expr{
							&ast.BasicLit{
								Kind:  token.STRING,
								Value: fmt.Sprintf(`"%s: Render called"`, comp.Name),
							},
						},
					},
				})
			}

			// Add return statement
			stmts = append(stmts, &ast.ReturnStmt{
				Results: []ast.Expr{body},
			})

			return &ast.BlockStmt{List: stmts}
		}(),
	}
}

// generateBody generates code for component body
func (g *Generator) generateBody(body *guixast.Body) ast.Expr {
	// Check if we need an IIFE (for VarDecls or ExprStmts)
	hasExprStmts := false
	for _, child := range body.Children {
		if child.ExprStmt != nil {
			hasExprStmts = true
			break
		}
	}

	// If there are variable declarations, statements, or expression statements, wrap everything in an IIFE
	if len(body.VarDecls) > 0 || len(body.Statements) > 0 || hasExprStmts {
		stmts := make([]ast.Stmt, 0)

		// Add variable declarations
		// VarDecls with inferable types (like channels) are hoisted to struct fields
		// and initialized in the constructor - skip them here in Render
		// All other VarDecls remain as local variables (including multiple assignments)
		for _, varDecl := range body.VarDecls {
			// Check if ALL variables in this decl can be hoisted
			// For now, only hoist if there's a single variable with an inferable type
			canHoist := len(varDecl.Names) == 1 && len(varDecl.Values) == 1 &&
				g.inferTypeFromExpr(varDecl.Values[0]) != nil

			// Check if this is a channel receive variable (skip - will be accessed via c.current<ChannelName>)
			isChannelReceive := len(varDecl.Names) == 1 &&
				g.channelReceiveVars != nil &&
				g.channelReceiveVars[varDecl.Names[0]] != ""

			if canHoist || isChannelReceive {
				// Hoisted field or channel receive - skip initialization in Render
				continue
			} else {
				// Local variable(s) - generate: name := value or n, err := value
				lhs := make([]ast.Expr, len(varDecl.Names))
				for i, name := range varDecl.Names {
					lhs[i] = ast.NewIdent(name)
				}

				rhs := make([]ast.Expr, len(varDecl.Values))
				for i, val := range varDecl.Values {
					rhs[i] = g.generateExpr(val)
				}

				stmts = append(stmts, &ast.AssignStmt{
					Lhs: lhs,
					Tok: g.assignOpToToken(varDecl.Op),
					Rhs: rhs,
				})
			}
		}

		// Add statements (but skip initialization statements for hoisted variables)
		for _, stmt := range body.Statements {
			// Skip channel sends to hoisted variables - those are initialization
			// and should only happen in the constructor, not every render
			if stmt.Assignment != nil && stmt.Assignment.Op == "<-" {
				if g.hoistedVars != nil && g.hoistedVars[stmt.Assignment.Left] {
					// Skip this - it's an initialization statement
					continue
				}
			}
			stmts = append(stmts, g.generateBodyStatement(stmt))
		}

		// Add expression statements (function calls)
		// Collect only the UI nodes (non-ExprStmt children)
		var uiChildren []*guixast.Node
		for _, child := range body.Children {
			if child.ExprStmt != nil {
				// Execute expression statement
				stmts = append(stmts, &ast.ExprStmt{
					X: g.generateCallOrSelect(child.ExprStmt.Expr),
				})
			} else {
				// Keep for UI tree
				uiChildren = append(uiChildren, child)
			}
		}

		// Generate the UI tree from non-statement children
		var uiExpr ast.Expr
		if len(uiChildren) == 0 {
			uiExpr = &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("runtime"),
					Sel: ast.NewIdent("Div"),
				},
			}
		} else if len(uiChildren) == 1 {
			uiExpr = g.generateNode(uiChildren[0])
		} else {
			// Multiple children - use Fragment
			args := make([]ast.Expr, len(uiChildren))
			for i, child := range uiChildren {
				args[i] = g.generateNode(child)
			}
			uiExpr = &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("runtime"),
					Sel: ast.NewIdent("Fragment"),
				},
				Args: args,
			}
		}

		// Return the UI tree
		stmts = append(stmts, &ast.ReturnStmt{
			Results: []ast.Expr{uiExpr},
		})

		// Wrap in IIFE
		return &ast.CallExpr{
			Fun: &ast.FuncLit{
				Type: &ast.FuncType{
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   ast.NewIdent("runtime"),
										Sel: ast.NewIdent("VNode"),
									},
								},
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: stmts,
				},
			},
		}
	}

	// No statements - simple case
	if len(body.Children) == 0 {
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent("Div"),
			},
		}
	}

	if len(body.Children) == 1 {
		return g.generateNode(body.Children[0])
	}

	// Multiple children - use Fragment
	args := make([]ast.Expr, len(body.Children))
	for i, child := range body.Children {
		args[i] = g.generateNode(child)
	}

	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent("Fragment"),
		},
		Args: args,
	}
}

// generateNode generates code for a node
func (g *Generator) generateNode(node *guixast.Node) ast.Expr {
	if node.Element != nil {
		return g.generateElement(node.Element)
	}

	if node.Text != nil {
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent("Text"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.STRING,
					Value: node.Text.Text,
				},
			},
		}
	}

	if node.Template != nil {
		return g.generateTemplate(node.Template)
	}

	// Default: empty div
	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent("Div"),
		},
	}
}

// Known DOM element names (common HTML elements)
var knownDOMElements = map[string]bool{
	"Div": true, "Span": true, "P": true, "A": true, "Button": true, "Input": true,
	"H1": true, "H2": true, "H3": true, "H4": true, "H5": true, "H6": true,
	"Ul": true, "Li": true, "Ol": true, "Img": true, "Form": true, "Label": true,
	"Select": true, "Option": true, "Textarea": true, "Table": true, "Tr": true,
	"Td": true, "Th": true, "Thead": true, "Tbody": true, "Tfoot": true,
	"Header": true, "Footer": true, "Nav": true, "Section": true, "Article": true,
	"Aside": true, "Main": true, "Figure": true, "Figcaption": true,
}

// generateElement generates code for an element
func (g *Generator) generateElement(elem *guixast.Element) ast.Expr {
	args := []ast.Expr{}

	// Check if this is a custom component
	// A tag is a component if:
	// 1. It's defined in the current file (in g.components map), OR
	// 2. It starts with a capital letter AND is NOT a known DOM element
	isComponent := g.components[elem.Tag] || (len(elem.Tag) > 0 && elem.Tag[0] >= 'A' && elem.Tag[0] <= 'Z' && !knownDOMElements[elem.Tag])

	// Add props as arguments
	for _, prop := range elem.Props {
		if isComponent {
			// For components, props are passed as option functions: WithProp(value)
			args = append(args, &ast.CallExpr{
				Fun:  ast.NewIdent(prop.Name),
				Args: []ast.Expr{g.generateExpr(prop.Value)},
			})
		} else {
			// For DOM elements, wrap in runtime.Prop()
			args = append(args, g.generateProp(prop))
		}
	}

	// Add children
	for _, child := range elem.Children {
		args = append(args, g.generateNode(child))
	}

	// Generate function call
	if isComponent {
		// Check if this component is hoisted
		if hoistedInfo, isHoisted := g.hoistedComponentMap[elem]; isHoisted {
			// Hoisted component: just call Render on the hoisted instance
			// Generate: c.counterInstance.Render()
			return &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X: &ast.SelectorExpr{
						X:   ast.NewIdent("c"),
						Sel: ast.NewIdent(hoistedInfo.varName),
					},
					Sel: ast.NewIdent("Render"),
				},
			}
		}

		// Non-hoisted component: wrap in IIFE to call BindApp before Render
		// Generate:
		// func() *runtime.VNode {
		//     comp := NewComponent(...)
		//     if c.app != nil { comp.BindApp(c.app) }
		//     return comp.Render()
		// }()
		compVar := "_" + strings.ToLower(elem.Tag[:1]) + elem.Tag[1:]
		return &ast.CallExpr{
			Fun: &ast.FuncLit{
				Type: &ast.FuncType{
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   ast.NewIdent("runtime"),
										Sel: ast.NewIdent("VNode"),
									},
								},
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						// comp := NewComponent(...)
						&ast.AssignStmt{
							Lhs: []ast.Expr{ast.NewIdent(compVar)},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CallExpr{
									Fun:  ast.NewIdent("New" + elem.Tag),
									Args: args,
								},
							},
						},
						// if c.app != nil { comp.BindApp(c.app) }
						&ast.IfStmt{
							Cond: &ast.BinaryExpr{
								X: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("app"),
								},
								Op: token.NEQ,
								Y:  ast.NewIdent("nil"),
							},
							Body: &ast.BlockStmt{
								List: []ast.Stmt{
									&ast.ExprStmt{
										X: &ast.CallExpr{
											Fun: &ast.SelectorExpr{
												X:   ast.NewIdent(compVar),
												Sel: ast.NewIdent("BindApp"),
											},
											Args: []ast.Expr{
												&ast.SelectorExpr{
													X:   ast.NewIdent("c"),
													Sel: ast.NewIdent("app"),
												},
											},
										},
									},
								},
							},
						},
						// return comp.Render()
						&ast.ReturnStmt{
							Results: []ast.Expr{
								&ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent(compVar),
										Sel: ast.NewIdent("Render"),
									},
								},
							},
						},
					},
				},
			},
		}
	} else {
		// DOM element: call runtime.Element()
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent(elem.Tag),
			},
			Args: args,
		}
	}
}

// generateProp generates code for a prop/event handler
func (g *Generator) generateProp(prop *guixast.Prop) ast.Expr {
	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent(prop.Name),
		},
		Args: []ast.Expr{g.generateExpr(prop.Value)},
	}
}

// generateTemplate generates code for template interpolation
func (g *Generator) generateTemplate(tmpl *guixast.Template) ast.Expr {
	if len(tmpl.Fragments) == 0 {
		return &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("runtime"),
				Sel: ast.NewIdent("Text"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.STRING,
					Value: `""`,
				},
			},
		}
	}

	// Build string concatenation
	var parts []ast.Expr

	for _, frag := range tmpl.Fragments {
		if frag.Text != "" {
			parts = append(parts, &ast.BasicLit{
				Kind:  token.STRING,
				Value: fmt.Sprintf(`"%s"`, frag.Text),
			})
		} else if frag.Expr != nil {
			// Convert expression to string
			parts = append(parts, &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("fmt"),
					Sel: ast.NewIdent("Sprint"),
				},
				Args: []ast.Expr{g.generateExpr(frag.Expr)},
			})
		}
	}

	// Concatenate all parts
	var result ast.Expr
	if len(parts) == 0 {
		result = &ast.BasicLit{Kind: token.STRING, Value: `""`}
	} else if len(parts) == 1 {
		result = parts[0]
	} else {
		result = parts[0]
		for i := 1; i < len(parts); i++ {
			result = &ast.BinaryExpr{
				X:  result,
				Op: token.ADD,
				Y:  parts[i],
			}
		}
	}

	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent("Text"),
		},
		Args: []ast.Expr{result},
	}
}

// generateExpr generates code for an expression
func (g *Generator) generateExpr(expr *guixast.Expr) ast.Expr {
	if expr == nil {
		return ast.NewIdent("nil")
	}

	// Generate the left (primary) expression
	left := g.generatePrimary(expr.Left)

	// If there are no binary operations, return the left expression as-is
	if len(expr.BinOps) == 0 {
		return left
	}

	// Build binary expression chain (left-associative)
	result := left
	for _, binOp := range expr.BinOps {
		right := g.generatePrimary(binOp.Right)
		result = &ast.BinaryExpr{
			X:  result,
			Op: g.binaryOpToToken(binOp.Op),
			Y:  right,
		}
	}

	return result
}

// generatePrimary generates code for a primary expression
func (g *Generator) generatePrimary(primary *guixast.Primary) ast.Expr {
	if primary == nil {
		return ast.NewIdent("nil")
	}

	if primary.Unary != nil {
		return &ast.UnaryExpr{
			Op: g.unaryOpToToken(primary.Unary.Op),
			X:  g.generatePrimary(primary.Unary.Right),
		}
	}

	if primary.Literal != nil {
		return g.generateLiteral(primary.Literal)
	}

	if primary.CompositeLit != nil {
		return g.generateCompositeLit(primary.CompositeLit)
	}

	if primary.MakeCall != nil {
		return g.generateMakeCall(primary.MakeCall)
	}

	if primary.CallOrSel != nil {
		return g.generateCallOrSelect(primary.CallOrSel)
	}

	if primary.Paren != nil {
		// Parenthesized expression
		return &ast.ParenExpr{
			X: g.generateExpr(primary.Paren),
		}
	}

	if primary.Ident != "" {
		// Check if it's a channel receive variable (e.g., currentState -> c.currentStateChannel)
		if g.channelReceiveVars != nil {
			if channelName, ok := g.channelReceiveVars[primary.Ident]; ok {
				return &ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent("current" + channelName),
				}
			}
		}
		// Check if it's a hoisted variable (stored as-is in component struct)
		if g.hoistedVars != nil && g.hoistedVars[primary.Ident] {
			return &ast.SelectorExpr{
				X:   ast.NewIdent("c"),
				Sel: ast.NewIdent(primary.Ident), // Use exact name, not capitalized
			}
		}
		// Check if it's a component parameter (should be converted to c.FieldName)
		if g.componentParams != nil && g.componentParams[primary.Ident] {
			return &ast.SelectorExpr{
				X:   ast.NewIdent("c"),
				Sel: ast.NewIdent(capitalize(primary.Ident)),
			}
		}
		// Otherwise it's a local variable or other identifier, use as-is
		return ast.NewIdent(primary.Ident)
	}

	if primary.FuncLit != nil {
		return g.generateFuncLit(primary.FuncLit)
	}

	if primary.ChannelOp != nil {
		// Instead of reading from the channel (which would block),
		// use the current value field that's updated by the channel listener
		return &ast.SelectorExpr{
			X:   ast.NewIdent("c"),
			Sel: ast.NewIdent("current" + capitalize(primary.ChannelOp.Channel)),
		}
	}

	// Default: identifier
	return ast.NewIdent("nil")
}

// unaryOpToToken converts a unary operator string to a token
func (g *Generator) unaryOpToToken(op string) token.Token {
	switch op {
	case "!":
		return token.NOT
	case "-":
		return token.SUB
	case "+":
		return token.ADD
	default:
		return token.NOT // Default fallback
	}
}

// binaryOpToToken converts a binary operator string to a token
func (g *Generator) binaryOpToToken(op string) token.Token {
	switch op {
	case "+":
		return token.ADD
	case "-":
		return token.SUB
	case "*":
		return token.MUL
	case "/":
		return token.QUO
	case "==":
		return token.EQL
	case "!=":
		return token.NEQ
	case "<":
		return token.LSS
	case "<=":
		return token.LEQ
	case ">":
		return token.GTR
	case ">=":
		return token.GEQ
	case "&&":
		return token.LAND
	case "||":
		return token.LOR
	default:
		return token.ADD // Default fallback
	}
}

// generateCompositeLit generates code for a composite literal (struct initialization)
func (g *Generator) generateCompositeLit(lit *guixast.CompositeLit) ast.Expr {
	elts := make([]ast.Expr, len(lit.Elements))
	for i, elem := range lit.Elements {
		elts[i] = &ast.KeyValueExpr{
			Key:   ast.NewIdent(elem.Key),
			Value: g.generateExpr(elem.Value),
		}
	}

	return &ast.CompositeLit{
		Type: ast.NewIdent(lit.Type),
		Elts: elts,
	}
}

// generateLiteral generates code for a literal
func (g *Generator) generateLiteral(lit *guixast.Literal) ast.Expr {
	if lit.String != nil {
		return &ast.BasicLit{
			Kind:  token.STRING,
			Value: *lit.String,
		}
	}

	if lit.Number != nil {
		return &ast.BasicLit{
			Kind:  token.INT,
			Value: *lit.Number,
		}
	}

	if lit.Bool != nil {
		return ast.NewIdent(*lit.Bool)
	}

	return ast.NewIdent("nil")
}

// generateMakeCall generates code for a make() function call
// Example: make(chan int, 10)
func (g *Generator) generateMakeCall(makeCall *guixast.MakeCall) ast.Expr {
	args := []ast.Expr{
		// First argument is the channel type
		&ast.ChanType{
			Dir:   ast.SEND | ast.RECV,
			Value: g.typeToAST(makeCall.ChanType),
		},
	}

	// Add size argument if present
	if makeCall.Size != nil {
		args = append(args, g.generateExpr(makeCall.Size))
	}

	return &ast.CallExpr{
		Fun:  ast.NewIdent("make"),
		Args: args,
	}
}

// generateCallOrSelect generates code for a call or selector expression
// If Args is present, generates a call. Otherwise, generates a selector.
func (g *Generator) generateCallOrSelect(cos *guixast.CallOrSelect) ast.Expr {
	// Check if this is a simple identifier (no fields, no args)
	if len(cos.Fields) == 0 && len(cos.Args) == 0 {
		// Check if it's a hoisted variable
		if g.hoistedVars != nil && g.hoistedVars[cos.Base] {
			return &ast.SelectorExpr{
				X:   ast.NewIdent("c"),
				Sel: ast.NewIdent(cos.Base),
			}
		}
		// Check if it's a component parameter
		if g.componentParams != nil && g.componentParams[cos.Base] {
			return &ast.SelectorExpr{
				X:   ast.NewIdent("c"),
				Sel: ast.NewIdent(capitalize(cos.Base)),
			}
		}
	}

	// Build the base selector expression from base and fields
	// Check if base is a channel receive variable that needs to be replaced
	var expr ast.Expr
	if g.channelReceiveVars != nil {
		if channelName, ok := g.channelReceiveVars[cos.Base]; ok {
			// Replace base with c.current<ChannelName>
			expr = &ast.SelectorExpr{
				X:   ast.NewIdent("c"),
				Sel: ast.NewIdent("current" + channelName),
			}
		} else {
			expr = ast.NewIdent(cos.Base)
		}
	} else {
		expr = ast.NewIdent(cos.Base)
	}

	for _, field := range cos.Fields {
		expr = &ast.SelectorExpr{
			X:   expr,
			Sel: ast.NewIdent(field),
		}
	}

	// If there are args, wrap in a call expression
	if cos.Args != nil {
		args := make([]ast.Expr, len(cos.Args))
		for i, arg := range cos.Args {
			args[i] = g.generateExpr(arg)
		}
		return &ast.CallExpr{
			Fun:  expr,
			Args: args,
		}
	}

	// Otherwise, just return the selector expression
	return expr
}

// generateFuncLit generates code for a function literal
func (g *Generator) generateFuncLit(fn *guixast.FuncLit) ast.Expr {
	params := make([]*ast.Field, len(fn.Params))
	for i, param := range fn.Params {
		params[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(param.Name)},
			Type:  g.typeToAST(param.Type),
		}
	}

	var results *ast.FieldList
	if len(fn.Results) > 0 {
		resultFields := make([]*ast.Field, len(fn.Results))
		for i, result := range fn.Results {
			resultFields[i] = &ast.Field{
				Type: g.typeToAST(result),
			}
		}
		results = &ast.FieldList{List: resultFields}
	}

	return &ast.FuncLit{
		Type: &ast.FuncType{
			Params:  &ast.FieldList{List: params},
			Results: results,
		},
		Body: g.generateFuncBody(fn.Body),
	}
}

// generateFuncBody generates code for a function body
func (g *Generator) generateFuncBody(body *guixast.FuncBody) *ast.BlockStmt {
	stmts := make([]ast.Stmt, len(body.Statements))
	for i, stmt := range body.Statements {
		stmts[i] = g.generateStatement(stmt)
	}
	return &ast.BlockStmt{List: stmts}
}

// generateBodyStatement generates code for a body statement
func (g *Generator) generateBodyStatement(stmt *guixast.BodyStatement) ast.Stmt {
	if stmt.VarDecl != nil {
		lhs := make([]ast.Expr, len(stmt.VarDecl.Names))
		for i, name := range stmt.VarDecl.Names {
			lhs[i] = ast.NewIdent(name)
		}

		rhs := make([]ast.Expr, len(stmt.VarDecl.Values))
		for i, val := range stmt.VarDecl.Values {
			rhs[i] = g.generateExpr(val)
		}

		return &ast.AssignStmt{
			Lhs: lhs,
			Tok: token.DEFINE,
			Rhs: rhs,
		}
	}

	if stmt.Assignment != nil {
		// Handle channel send operation
		if stmt.Assignment.Op == "<-" {
			// Check if channel is a hoisted variable (only for simple identifiers)
			var chanExpr ast.Expr
			if len(stmt.Assignment.LeftSelector) == 0 && g.hoistedVars != nil && g.hoistedVars[stmt.Assignment.Left] {
				chanExpr = &ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent(stmt.Assignment.Left),
				}
			} else {
				chanExpr = g.generateAssignmentLHS(stmt.Assignment)
			}

			return &ast.SendStmt{
				Chan:  chanExpr,
				Value: g.generateExpr(stmt.Assignment.Right),
			}
		}

		return &ast.AssignStmt{
			Lhs: []ast.Expr{g.generateAssignmentLHS(stmt.Assignment)},
			Tok: g.assignOpToToken(stmt.Assignment.Op),
			Rhs: []ast.Expr{g.generateExpr(stmt.Assignment.Right)},
		}
	}

	if stmt.Return != nil {
		if len(stmt.Return.Values) == 0 {
			return &ast.ReturnStmt{}
		}

		results := make([]ast.Expr, len(stmt.Return.Values))
		for i, val := range stmt.Return.Values {
			results[i] = g.generateExpr(val)
		}
		return &ast.ReturnStmt{
			Results: results,
		}
	}

	if stmt.If != nil {
		// Generate if statement
		ifStmt := &ast.IfStmt{
			Cond: g.generateExpr(stmt.If.Cond),
			Body: g.generateFuncBody(stmt.If.Body),
		}
		if stmt.If.Else != nil {
			if stmt.If.Else.IfStmt != nil {
				ifStmt.Else = g.generateBodyStatement(&guixast.BodyStatement{
					If: stmt.If.Else.IfStmt,
				})
			} else if stmt.If.Else.Body != nil {
				ifStmt.Else = g.generateFuncBody(stmt.If.Else.Body)
			}
		}
		return ifStmt
	}

	if stmt.For != nil {
		// TODO: Generate for loop statement
		return &ast.EmptyStmt{}
	}

	return &ast.EmptyStmt{}
}

// generateStatement generates code for a statement
func (g *Generator) generateStatement(stmt *guixast.Statement) ast.Stmt {
	if stmt.Assignment != nil {
		// Handle channel send operation
		if stmt.Assignment.Op == "<-" {
			// Check if channel is a hoisted variable (only for simple identifiers)
			var chanExpr ast.Expr
			if len(stmt.Assignment.LeftSelector) == 0 && g.hoistedVars != nil && g.hoistedVars[stmt.Assignment.Left] {
				chanExpr = &ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent(stmt.Assignment.Left),
				}
			} else {
				chanExpr = g.generateAssignmentLHS(stmt.Assignment)
			}

			return &ast.SendStmt{
				Chan:  chanExpr,
				Value: g.generateExpr(stmt.Assignment.Right),
			}
		}

		return &ast.AssignStmt{
			Lhs: []ast.Expr{g.generateAssignmentLHS(stmt.Assignment)},
			Tok: g.assignOpToToken(stmt.Assignment.Op),
			Rhs: []ast.Expr{g.generateExpr(stmt.Assignment.Right)},
		}
	}

	if stmt.VarDecl != nil {
		lhs := make([]ast.Expr, len(stmt.VarDecl.Names))
		for i, name := range stmt.VarDecl.Names {
			lhs[i] = ast.NewIdent(name)
		}

		rhs := make([]ast.Expr, len(stmt.VarDecl.Values))
		for i, val := range stmt.VarDecl.Values {
			rhs[i] = g.generateExpr(val)
		}

		return &ast.AssignStmt{
			Lhs: lhs,
			Tok: g.assignOpToToken(stmt.VarDecl.Op),
			Rhs: rhs,
		}
	}

	if stmt.Expr != nil {
		return &ast.ExprStmt{
			X: g.generateExpr(stmt.Expr),
		}
	}

	if stmt.Return != nil {
		results := make([]ast.Expr, len(stmt.Return.Values))
		for i, val := range stmt.Return.Values {
			results[i] = g.generateExpr(val)
		}
		return &ast.ReturnStmt{Results: results}
	}

	if stmt.If != nil {
		// Generate if statement
		ifStmt := &ast.IfStmt{
			Cond: g.generateExpr(stmt.If.Cond),
			Body: g.generateFuncBody(stmt.If.Body),
		}
		if stmt.If.Else != nil {
			if stmt.If.Else.IfStmt != nil {
				// else if
				ifStmt.Else = g.generateStatement(&guixast.Statement{
					If: stmt.If.Else.IfStmt,
				})
			} else if stmt.If.Else.Body != nil {
				// else block
				ifStmt.Else = g.generateFuncBody(stmt.If.Else.Body)
			}
		}
		return ifStmt
	}

	if stmt.For != nil {
		// TODO: Generate for loop statement
		return &ast.EmptyStmt{}
	}

	return &ast.EmptyStmt{}
}

// typeToAST converts a Guix type to Go AST type
// Known runtime types that should be qualified with runtime package
var runtimeTypes = map[string]bool{
	"Event": true, "VNode": true, "App": true,
}

func (g *Generator) typeToAST(t *guixast.Type) ast.Expr {
	if t == nil {
		return ast.NewIdent("interface{}")
	}

	var base ast.Expr
	// Use runtime.TypeName for known runtime types
	if runtimeTypes[t.Name] {
		base = &ast.SelectorExpr{
			X:   ast.NewIdent("runtime"),
			Sel: ast.NewIdent(t.Name),
		}
	} else {
		base = ast.NewIdent(t.Name)
	}

	// Handle channel types
	// IsChannel && IsChan means "<-chan T" (receive-only)
	// IsChan only means "chan T" (bidirectional)
	if t.IsChannel && t.IsChan {
		base = &ast.ChanType{
			Dir:   ast.RECV,
			Value: base,
		}
	} else if t.IsChan {
		base = &ast.ChanType{
			Dir:   ast.SEND | ast.RECV,
			Value: base,
		}
	}

	if t.IsPointer {
		base = &ast.StarExpr{X: base}
	}

	return base
}

// generateAssignmentLHS generates the left-hand side expression for an assignment
func (g *Generator) generateAssignmentLHS(assignment *guixast.Assignment) ast.Expr {
	if len(assignment.LeftSelector) == 0 {
		// Simple identifier
		return ast.NewIdent(assignment.Left)
	}

	// Build selector expression chain
	var expr ast.Expr = ast.NewIdent(assignment.Left)
	for _, field := range assignment.LeftSelector {
		expr = &ast.SelectorExpr{
			X:   expr,
			Sel: ast.NewIdent(field),
		}
	}
	return expr
}

// assignOpToToken converts assignment operator string to token
func (g *Generator) assignOpToToken(op string) token.Token {
	switch op {
	case ":=":
		return token.DEFINE
	case "=":
		return token.ASSIGN
	case "+=":
		return token.ADD_ASSIGN
	case "-=":
		return token.SUB_ASSIGN
	case "*=":
		return token.MUL_ASSIGN
	case "/=":
		return token.QUO_ASSIGN
	case "<-":
		return token.ARROW
	default:
		return token.ASSIGN
	}
}

// generateMountMethod generates the Mount method
func (g *Generator) generateMountMethod(comp *guixast.Component) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Mount"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("parent")},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("js"),
							Sel: ast.NewIdent("Value"),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("runtime"),
							Sel: ast.NewIdent("Mount"),
						},
						Args: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("Render"),
								},
							},
							ast.NewIdent("parent"),
						},
					},
				},
			},
		},
	}
}

// generateUnmountMethod generates the Unmount method
func (g *Generator) generateUnmountMethod(comp *guixast.Component) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Unmount"),
		Type: &ast.FuncType{},
		Body: &ast.BlockStmt{},
	}
}

// generateUpdateMethod generates the Update method
func (g *Generator) generateUpdateMethod(comp *guixast.Component) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("Update"),
		Type: &ast.FuncType{},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X: &ast.SelectorExpr{
							X:   ast.NewIdent("c"),
							Sel: ast.NewIdent("app"),
						},
						Op: token.NEQ,
						Y:  ast.NewIdent("nil"),
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ExprStmt{
								X: &ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("c"),
											Sel: ast.NewIdent("app"),
										},
										Sel: ast.NewIdent("Update"),
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateBindAppMethod generates the BindApp method for components with channels
func (g *Generator) generateBindAppMethod(comp *guixast.Component) *ast.FuncDecl {
	stmts := []ast.Stmt{}

	// Add verbose logging if enabled
	if g.verbose {
		stmts = append(stmts, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: ast.NewIdent("log"),
				Args: []ast.Expr{
					&ast.BasicLit{
						Kind:  token.STRING,
						Value: fmt.Sprintf(`"%s: BindApp called"`, comp.Name),
					},
				},
			},
		})
	}

	// c.app = app
	stmts = append(stmts,
		&ast.AssignStmt{
			Lhs: []ast.Expr{
				&ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent("app"),
				},
			},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{ast.NewIdent("app")},
		},
	)

	// Check if component has channel parameters
	hasChannels := g.hasChannelParams(comp)

	if hasChannels {
		// Add early return if listeners already started
		// if c.listenersStarted { return }
		stmts = append(stmts, &ast.IfStmt{
			Cond: &ast.SelectorExpr{
				X:   ast.NewIdent("c"),
				Sel: ast.NewIdent("listenersStarted"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{},
				},
			},
		})
	}

	// For each channel parameter, start a listener
	for _, param := range comp.Params {
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			// if c.ChannelName != nil { c.startChannelNameListener() }
			stmts = append(stmts, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X: &ast.SelectorExpr{
						X:   ast.NewIdent("c"),
						Sel: ast.NewIdent(capitalize(param.Name)),
					},
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("c"),
									Sel: ast.NewIdent("start" + capitalize(param.Name) + "Listener"),
								},
							},
						},
					},
				},
			})
		}
	}

	// Call BindApp on child component instances
	if comp.Body != nil {
		childComponents := g.collectChildComponents(comp.Body.Children)
		for _, childInfo := range childComponents {
			// Generate: if c.childInstance != nil { c.childInstance.BindApp(app) }
			stmts = append(stmts, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X: &ast.SelectorExpr{
						X:   ast.NewIdent("c"),
						Sel: ast.NewIdent(childInfo.varName),
					},
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X: &ast.SelectorExpr{
										X:   ast.NewIdent("c"),
										Sel: ast.NewIdent(childInfo.varName),
									},
									Sel: ast.NewIdent("BindApp"),
								},
								Args: []ast.Expr{ast.NewIdent("app")},
							},
						},
					},
				},
			})
		}
	}

	// Set flag after starting listeners
	if hasChannels {
		stmts = append(stmts, &ast.AssignStmt{
			Lhs: []ast.Expr{
				&ast.SelectorExpr{
					X:   ast.NewIdent("c"),
					Sel: ast.NewIdent("listenersStarted"),
				},
			},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{ast.NewIdent("true")},
		})
	}

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("c")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(comp.Name),
					},
				},
			},
		},
		Name: ast.NewIdent("BindApp"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("app")},
						Type: &ast.StarExpr{
							X: &ast.SelectorExpr{
								X:   ast.NewIdent("runtime"),
								Sel: ast.NewIdent("App"),
							},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}
}

// generateChannelListenerMethods generates listener methods for each channel parameter
func (g *Generator) generateChannelListenerMethods(comp *guixast.Component) []ast.Decl {
	var decls []ast.Decl

	for _, param := range comp.Params {
		if param.Type != nil && (param.Type.IsChannel || param.Type.IsChan) {
			// Generate: func (c *Component) startChannelNameListener() { go func() { for val := range c.ChannelName { c.currentChannelName = val; c.app.Update() } }() }
			decls = append(decls, &ast.FuncDecl{
				Recv: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{ast.NewIdent("c")},
							Type: &ast.StarExpr{
								X: ast.NewIdent(comp.Name),
							},
						},
					},
				},
				Name: ast.NewIdent("start" + capitalize(param.Name) + "Listener"),
				Type: &ast.FuncType{},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						// go func() { ... }()
						&ast.GoStmt{
							Call: &ast.CallExpr{
								Fun: &ast.FuncLit{
									Type: &ast.FuncType{},
									Body: &ast.BlockStmt{
										List: []ast.Stmt{
											// for val := range c.ChannelName { ... }
											&ast.RangeStmt{
												Key:   ast.NewIdent("val"),
												Value: nil,
												Tok:   token.DEFINE,
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("c"),
													Sel: ast.NewIdent(capitalize(param.Name)),
												},
												Body: &ast.BlockStmt{
													List: []ast.Stmt{
														// c.currentChannelName = val
														&ast.AssignStmt{
															Lhs: []ast.Expr{
																&ast.SelectorExpr{
																	X:   ast.NewIdent("c"),
																	Sel: ast.NewIdent("current" + capitalize(param.Name)),
																},
															},
															Tok: token.ASSIGN,
															Rhs: []ast.Expr{ast.NewIdent("val")},
														},
														// if c.app != nil { c.app.Update() }
														&ast.IfStmt{
															Cond: &ast.BinaryExpr{
																X: &ast.SelectorExpr{
																	X:   ast.NewIdent("c"),
																	Sel: ast.NewIdent("app"),
																},
																Op: token.NEQ,
																Y:  ast.NewIdent("nil"),
															},
															Body: &ast.BlockStmt{
																List: []ast.Stmt{
																	&ast.ExprStmt{
																		X: &ast.CallExpr{
																			Fun: &ast.SelectorExpr{
																				X: &ast.SelectorExpr{
																					X:   ast.NewIdent("c"),
																					Sel: ast.NewIdent("app"),
																				},
																				Sel: ast.NewIdent("Update"),
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			})
		}
	}

	return decls
}

// Helper functions

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
