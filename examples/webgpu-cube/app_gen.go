//go:build js && wasm
// +build js,wasm

// Code generated by guix. DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/gaarutyunov/guix/pkg/runtime"
	"syscall/js"
)

type App struct {
	app              *runtime.App
	rotationX        float64
	rotationY        float64
	autoRotate       bool
	speed            float64
	commands         chan ControlCommand
	controlState     chan ControlState
	controlsInstance *Controls
}

func NewApp() *App {
	c := &App{}
	c.rotationX = 0.0
	c.rotationY = 0.0
	c.autoRotate = true
	c.speed = 1.0
	c.commands = make(chan ControlCommand, 10)
	c.controlState = make(chan ControlState, 10)
	go func() {
		state := ControlState{AutoRotate: c.autoRotate, Speed: float32(c.speed)}
		log(fmt.Sprintf("[App] Sending initial state: %s", state.String()))
		c.controlState <- state
	}()
	go func() {
		log("[App] Command processing goroutine started")
		for cmd := range c.commands {
			log(fmt.Sprintf("[App] Received command: %s", cmd.String()))
			switch cmd.Type {
			case "rotX":
				c.rotationX += float64(cmd.Value)
				log(fmt.Sprintf("[App] Updated rotationX to: %.2f", c.rotationX))
			case "rotY":
				c.rotationY += float64(cmd.Value)
				log(fmt.Sprintf("[App] Updated rotationY to: %.2f", c.rotationY))
			case "autoRotate":
				c.autoRotate = !c.autoRotate
				log(fmt.Sprintf("[App] Toggled autoRotate to: %t", c.autoRotate))
			case "speed":
				c.speed = float64(cmd.Value)
				log(fmt.Sprintf("[App] Updated speed to: %.2f", c.speed))
			}
			state := ControlState{AutoRotate: c.autoRotate, Speed: float32(c.speed)}
			select {
			case c.controlState <- state:
				log(fmt.Sprintf("[App] Sent state update: %s", state.String()))
			default:
			}
		}
		log("[App] Command processing goroutine ended")
	}()
	c.controlsInstance = NewControls(WithCommands(c.commands), WithState(c.controlState))
	return c
}
func (c *App) BindApp(app *runtime.App) {
	c.app = app
	if c.controlsInstance != nil {
		c.controlsInstance.BindApp(app)
	}
}
func (c *App) Render() *runtime.VNode {
	return func() *runtime.VNode {
		renderUpdate := func(delta float64, rendererInterface interface {
		}) {
			if c.autoRotate {
				c.rotationY = c.rotationY + (delta * c.speed)
				c.rotationX = c.rotationX + (delta * c.speed * 0.5)
			}

			// Update mesh transform with new rotation values
			if renderer, ok := rendererInterface.(*runtime.SceneRenderer); ok && len(renderer.Meshes) > 0 {
				transform := runtime.NewTransform()
				transform.Position = runtime.Vec3{X: 0, Y: 0, Z: 0}
				transform.Rotation = runtime.Vec3{X: float32(c.rotationX), Y: float32(c.rotationY), Z: 0}
				transform.Scale = runtime.Vec3{X: 1, Y: 1, Z: 1}
				renderer.UpdateMeshTransform(0, transform)
			}
		}
		return runtime.Div(runtime.Class("webgpu-container"), runtime.Canvas(runtime.ID("webgpu-canvas"), runtime.Width(500), runtime.Height(500), runtime.GPURenderUpdate(renderUpdate), runtime.GPUScene(NewCubeScene(float32(c.rotationX), float32(c.rotationY)))), c.controlsInstance.Render())
	}()
}
func (c *App) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *App) Unmount() {
}
func (c *App) Update() {
	if c.app != nil {
		c.app.Update()
	}
}
