//go:build js && wasm
// +build js,wasm

// Code generated by guix. DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/gaarutyunov/guix/pkg/runtime"
	"syscall/js"
)

type CounterProps struct {
	CounterChannel chan int
}
type CounterOption func(*Counter)

func WithCounterChannel(v chan int) CounterOption {
	return func(c *Counter) {
		c.CounterChannel = v
	}
}

type Counter struct {
	app                   *runtime.App
	CounterChannel        chan int
	currentCounterChannel int
	listenersStarted      bool
}

func NewCounter(opts ...CounterOption) *Counter {
	c := &Counter{}
	for _, opt := range opts {
		opt(c)
	}
	if c.CounterChannel != nil {
		c.currentCounterChannel = <-c.CounterChannel
	}
	return c
}
func (c *Counter) BindApp(app *runtime.App) {
	c.app = app
	if c.listenersStarted {
		return
	}
	if c.CounterChannel != nil {
		c.startCounterChannelListener()
	}
	c.listenersStarted = true
}
func (c *Counter) startCounterChannelListener() {
	go func() {
		for val := range c.CounterChannel {
			c.currentCounterChannel = val
			if c.app != nil {
				c.app.Update()
			}
		}
	}()
}
func (c *Counter) Render() *runtime.VNode {
	return runtime.Div(runtime.Class("counter-display"), runtime.Span(runtime.Class("counter-value"), runtime.Text("Counter: "+fmt.Sprint(c.currentCounterChannel))))
}
func (c *Counter) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *Counter) Unmount() {
}
func (c *Counter) Update() {
	if c.app != nil {
		c.app.Update()
	}
}
