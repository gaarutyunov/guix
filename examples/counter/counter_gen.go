// Code generated by guix. DO NOT EDIT.
package main

import (
	"fmt"
	"strconv"
	"syscall/js"

	"github.com/gaarutyunov/guix/pkg/runtime"
)

// Counter component that displays a counter value
type Counter struct {
	app          *runtime.App
	currentValue int
}

func NewCounter() *Counter {
	return &Counter{
		currentValue: 0,
	}
}

func (c *Counter) BindApp(app *runtime.App) {
	c.app = app
}

func (c *Counter) Render() *runtime.VNode {
	return runtime.Div(
		runtime.Class("counter-display"),
		runtime.Span(
			runtime.Class("counter-value"),
			runtime.Text(fmt.Sprintf("Counter: %d", c.currentValue)),
		),
	)
}

func (c *Counter) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}

func (c *Counter) Unmount() {
}

func (c *Counter) Update() {
	if c.app != nil {
		c.app.Update()
	}
}

// App component
type App struct {
	app          *runtime.App
	counter      chan int
	counterComp  *Counter
	currentValue int
}

func NewApp() *App {
	app := &App{
		counter:      make(chan int, 10), // Buffered channel
		currentValue: 0,
	}
	// Create Counter component once
	app.counterComp = NewCounter()
	return app
}

func (c *App) BindApp(app *runtime.App) {
	c.app = app
	c.counterComp.BindApp(app)
	// Start listening to the counter channel
	c.startChannelListener()
}

// startChannelListener listens for values on the channel and triggers re-renders
func (c *App) startChannelListener() {
	go func() {
		for val := range c.counter {
			c.currentValue = val
			c.counterComp.currentValue = val
			if c.app != nil {
				c.app.Update()
			}
		}
	}()
}

func (c *App) Render() *runtime.VNode {
	return runtime.Div(
		runtime.Class("app-container"),
		runtime.H1(runtime.Text("Counter Example")),
		runtime.Div(
			runtime.Class("input-group"),
			runtime.Input(
				runtime.Type("number"),
				runtime.Placeholder("Enter a number"),
				runtime.Value(fmt.Sprint(c.currentValue)),
				runtime.ID("counter-input"),
				runtime.OnInput(func(e runtime.Event) {
					// Parse the input value and send to channel
					value := e.Target.Value
					if n, err := strconv.Atoi(value); err == nil {
						// Non-blocking send
						select {
						case c.counter <- n:
						default:
							// Channel full, skip
						}
					}
				}),
			),
		),
		c.counterComp.Render(),
	)
}

func (c *App) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}

func (c *App) Unmount() {
	if c.counter != nil {
		close(c.counter)
	}
}

func (c *App) Update() {
	if c.app != nil {
		c.app.Update()
	}
}
