//go:build js && wasm
// +build js,wasm

// Code generated by guix. DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/gaarutyunov/guix/pkg/runtime"
	"syscall/js"
)

type SimpleCard struct {
	app         *runtime.App
	Title       string
	Description string
}

func NewSimpleCard(title string, description string) *SimpleCard {
	c := &SimpleCard{}
	c.Title = title
	c.Description = description
	return c
}
func (c *SimpleCard) BindApp(app *runtime.App) {
	c.app = app
}
func (c *SimpleCard) Render() *runtime.VNode {
	return runtime.Div(runtime.Class("card"), runtime.H2(runtime.Class("card-title"), runtime.Text(fmt.Sprint(c.Title))), runtime.P(runtime.Class("card-description"), runtime.Text(fmt.Sprint(c.Description))))
}
func (c *SimpleCard) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *SimpleCard) Unmount() {
}
func (c *SimpleCard) Update() {
	if c.app != nil {
		c.app.Update()
	}
}

type ProductCard struct {
	app         *runtime.App
	ProductName string
	Price       float64
	InStock     bool
}

func NewProductCard(productName string, price float64, inStock bool) *ProductCard {
	c := &ProductCard{}
	c.ProductName = productName
	c.Price = price
	c.InStock = inStock
	return c
}
func (c *ProductCard) BindApp(app *runtime.App) {
	c.app = app
}
func (c *ProductCard) Render() *runtime.VNode {
	return runtime.Div(runtime.Class("product-card"), runtime.H2(runtime.Text(fmt.Sprint(c.ProductName))), runtime.P(runtime.Text("Price: $"+fmt.Sprint(c.Price))), runtime.Div())
}
func (c *ProductCard) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *ProductCard) Unmount() {
}
func (c *ProductCard) Update() {
	if c.app != nil {
		c.app.Update()
	}
}

type AutoCardProps struct {
	Title       string
	Subtitle    string
	Highlighted bool
}
type AutoCardOption func(*AutoCard)

func WithTitle(v string) AutoCardOption {
	return func(c *AutoCard) {
		c.Title = v
	}
}
func WithSubtitle(v string) AutoCardOption {
	return func(c *AutoCard) {
		c.Subtitle = v
	}
}
func WithHighlighted(v bool) AutoCardOption {
	return func(c *AutoCard) {
		c.Highlighted = v
	}
}

type AutoCard struct {
	app         *runtime.App
	Title       string
	Subtitle    string
	Highlighted bool
}

func NewAutoCard(opts ...AutoCardOption) *AutoCard {
	c := &AutoCard{}
	for _, opt := range opts {
		opt(c)
	}
	return c
}
func (c *AutoCard) BindApp(app *runtime.App) {
	c.app = app
}
func (c *AutoCard) Render() *runtime.VNode {
	return runtime.Div(runtime.Class("auto-card"), runtime.H1(runtime.Text(fmt.Sprint(c.Title))), runtime.P(runtime.Text(fmt.Sprint(c.Subtitle))), runtime.Div())
}
func (c *AutoCard) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *AutoCard) Unmount() {
}
func (c *AutoCard) Update() {
	if c.app != nil {
		c.app.Update()
	}
}

type MessageList struct {
	app      *runtime.App
	Messages []string
}

func NewMessageList(messages ...string) *MessageList {
	c := &MessageList{}
	c.Messages = messages
	return c
}
func (c *MessageList) BindApp(app *runtime.App) {
	c.app = app
}
func (c *MessageList) Render() *runtime.VNode {
	return runtime.Div(runtime.Class("message-list"), runtime.H2(runtime.Text("Messages")), runtime.Div())
}
func (c *MessageList) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *MessageList) Unmount() {
}
func (c *MessageList) Update() {
	if c.app != nil {
		c.app.Update()
	}
}

type LiveCounterProps struct {
	Count chan int
}
type LiveCounterOption func(*LiveCounter)

func WithCount(v chan int) LiveCounterOption {
	return func(c *LiveCounter) {
		c.Count = v
	}
}

type LiveCounter struct {
	app              *runtime.App
	Count            chan int
	currentCount     int
	listenersStarted bool
}

func NewLiveCounter(opts ...LiveCounterOption) *LiveCounter {
	c := &LiveCounter{}
	for _, opt := range opts {
		opt(c)
	}
	if c.Count != nil {
		c.currentCount = <-c.Count
	}
	return c
}
func (c *LiveCounter) BindApp(app *runtime.App) {
	c.app = app
	if c.listenersStarted {
		return
	}
	if c.Count != nil {
		c.startCountListener()
	}
	c.listenersStarted = true
}
func (c *LiveCounter) startCountListener() {
	go func() {
		for val := range c.Count {
			c.currentCount = val
			if c.app != nil {
				c.app.Update()
			}
		}
	}()
}
func (c *LiveCounter) Render() *runtime.VNode {
	return func() *runtime.VNode {
		return runtime.Div(runtime.Class("live-counter"), runtime.Span(runtime.Class("count-value"), runtime.Text("Count: "+fmt.Sprint(c.currentCount))))
	}()
}
func (c *LiveCounter) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *LiveCounter) Unmount() {
}
func (c *LiveCounter) Update() {
	if c.app != nil {
		c.app.Update()
	}
}
