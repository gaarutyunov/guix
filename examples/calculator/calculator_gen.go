//go:build js && wasm
// +build js,wasm

// Code generated by guix. DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/gaarutyunov/guix/pkg/runtime"
	"strconv"
	"strings"
	"syscall/js"
)

type CalculatorState struct {
	Tokens         []string
	CurrentInput   string
	JustCalculated bool
	LastResult     float64
}
type CalculatorProps struct {
	StateChannel chan CalculatorState
}
type CalculatorOption func(*Calculator)

func WithStateChannel(v chan CalculatorState) CalculatorOption {
	return func(c *Calculator) {
		c.StateChannel = v
	}
}

type Calculator struct {
	app                 *runtime.App
	StateChannel        chan CalculatorState
	currentStateChannel CalculatorState
	listenersStarted    bool
}

func NewCalculator(opts ...CalculatorOption) *Calculator {
	c := &Calculator{}
	for _, opt := range opts {
		opt(c)
	}
	if c.StateChannel != nil {
		c.currentStateChannel = <-c.StateChannel
	}
	return c
}
func (c *Calculator) BindApp(app *runtime.App) {
	c.app = app
	if c.listenersStarted {
		return
	}
	if c.StateChannel != nil {
		c.startStateChannelListener()
	}
	c.listenersStarted = true
}
func (c *Calculator) startStateChannelListener() {
	go func() {
		for val := range c.StateChannel {
			c.currentStateChannel = val
			if c.app != nil {
				c.app.Update()
			}
		}
	}()
}
func (c *Calculator) Render() *runtime.VNode {
	return func() *runtime.VNode {
		return runtime.Div(runtime.Class("calculator"), runtime.Div(runtime.Class("display"), runtime.Text(fmt.Sprint(buildDisplay(c.currentStateChannel)))), runtime.Div(runtime.Class("buttons"), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "7")
		}), runtime.Text("7")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "8")
		}), runtime.Text("8")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "9")
		}), runtime.Text("9")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "/")
		}), runtime.Text("÷"))), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "4")
		}), runtime.Text("4")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "5")
		}), runtime.Text("5")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "6")
		}), runtime.Text("6")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "*")
		}), runtime.Text("×"))), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "1")
		}), runtime.Text("1")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "2")
		}), runtime.Text("2")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "3")
		}), runtime.Text("3")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "-")
		}), runtime.Text("−"))), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "0")
		}), runtime.Text("0")), runtime.Button(runtime.Class("button clear"), runtime.OnClick(func(e runtime.Event) {
			handleClear(c.StateChannel)
		}), runtime.Text("C")), runtime.Button(runtime.Class("button equals"), runtime.OnClick(func(e runtime.Event) {
			handleEquals(c.StateChannel, c.currentStateChannel)
		}), runtime.Text("=")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "+")
		}), runtime.Text("+")))))
	}()
}
func (c *Calculator) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *Calculator) Unmount() {
}
func (c *Calculator) Update() {
	if c.app != nil {
		c.app.Update()
	}
}
func handleNumber(stateChannel chan CalculatorState, state CalculatorState, digit string) {
	if state.JustCalculated {
		state.Tokens = nil
		state.CurrentInput = digit
		state.JustCalculated = false
	} else {
		state.CurrentInput = state.CurrentInput + digit
	}
	stateChannel <- state
}
func handleOperator(stateChannel chan CalculatorState, state CalculatorState, operator string) {
	if state.JustCalculated {
		state.Tokens = nil
		state.Tokens = appendToken(state.Tokens, formatNumber(state.LastResult))
		state.Tokens = appendToken(state.Tokens, operator)
		state.CurrentInput = ""
		state.JustCalculated = false
	} else if state.CurrentInput != "" {
		state.Tokens = appendToken(state.Tokens, state.CurrentInput)
		state.Tokens = appendToken(state.Tokens, operator)
		state.CurrentInput = ""
	}
	stateChannel <- state
}
func handleEquals(stateChannel chan CalculatorState, state CalculatorState) {
	fullTokens := state.Tokens
	if state.CurrentInput != "" {
		fullTokens = appendToken(fullTokens, state.CurrentInput)
	}
	result := calculateFromTokens(fullTokens)
	state.Tokens = nil
	state.CurrentInput = ""
	state.LastResult = result
	state.JustCalculated = true
	stateChannel <- state
}
func handleClear(stateChannel chan CalculatorState) {
	stateChannel <- CalculatorState{Tokens: nil, CurrentInput: "", JustCalculated: false, LastResult: 0}
}
func buildDisplay(state CalculatorState) string {
	if state.JustCalculated {
		return formatNumber(state.LastResult)
	}
	display := tokensToString(state.Tokens)
	if state.CurrentInput != "" {
		if display != "" {
			display = display + " " + state.CurrentInput
		} else {
			display = state.CurrentInput
		}
	}
	if display == "" {
		display = "0"
	}
	return display
}
func appendToken(tokens []string, token string) []string {
	return append(tokens, token)
}
func tokensToString(tokens []string) string {
	return strings.Join(tokens, " ")
}
func calculateFromTokens(tokens []string) float64 {
	if len(tokens) == 0 {
		return 0
	}
	if len(tokens) == 1 {
		result, _ := strconv.ParseFloat(tokens[0], 64)
		return result
	}
	workingTokens := make([]string, len(tokens))
	copy(workingTokens, tokens)
	for i := 1; i < len(workingTokens); i += 0 {
		if i+1 < len(workingTokens) {
			operator := workingTokens[i]
			if (operator == "*") || (operator == "/") {
				left, _ := strconv.ParseFloat(workingTokens[i-1], 64)
				right, _ := strconv.ParseFloat(workingTokens[i+1], 64)
				result := calculate(left, right, operator)
				resultStr := formatNumber(result)
				newLen := len(workingTokens) - 2
				newTokens := make([]string, newLen)
				for j := 0; j < (i - 1); j += 1 {
					newTokens[j] = workingTokens[j]
				}
				newTokens[i-1] = resultStr
				for j := i + 2; j < len(workingTokens); j += 1 {
					newTokens[j-2] = workingTokens[j]
				}
				workingTokens = newTokens
			} else {
				i = i + 2
			}
		} else {
			i = i + 2
		}
	}
	for i := 1; i < len(workingTokens); i += 0 {
		if i+1 < len(workingTokens) {
			operator := workingTokens[i]
			if (operator == "+") || (operator == "-") {
				left, _ := strconv.ParseFloat(workingTokens[i-1], 64)
				right, _ := strconv.ParseFloat(workingTokens[i+1], 64)
				result := calculate(left, right, operator)
				resultStr := formatNumber(result)
				newLen := len(workingTokens) - 2
				newTokens := make([]string, newLen)
				for j := 0; j < (i - 1); j += 1 {
					newTokens[j] = workingTokens[j]
				}
				newTokens[i-1] = resultStr
				for j := i + 2; j < len(workingTokens); j += 1 {
					newTokens[j-2] = workingTokens[j]
				}
				workingTokens = newTokens
			} else {
				i = i + 2
			}
		} else {
			i = i + 2
		}
	}
	result, _ := strconv.ParseFloat(workingTokens[0], 64)
	return result
}
func calculate(a float64, b float64, operator string) float64 {
	result := b
	if operator == "+" {
		result = a + b
	} else if operator == "-" {
		result = a - b
	} else if operator == "*" {
		result = a * b
	} else if operator == "/" {
		if b != 0 {
			result = a / b
		} else {
			result = 0
		}
	}
	return result
}
func formatNumber(num float64) string {
	return fmt.Sprintf("%g", num)
}
func NewCalculatorStateChannel() chan CalculatorState {
	ch := make(chan CalculatorState, 10)
	ch <- CalculatorState{Tokens: nil, CurrentInput: "", JustCalculated: false, LastResult: 0}
	return ch
}
