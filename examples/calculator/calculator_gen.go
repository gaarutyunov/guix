//go:build js && wasm
// +build js,wasm

// Code generated by guix. DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/gaarutyunov/guix/pkg/runtime"
	"strconv"
	"strings"
	"syscall/js"
)

type CalculatorState struct {
	Display        string
	Expression     string
	LastResult     float64
	JustCalculated bool
}
type CalculatorProps struct {
	StateChannel chan CalculatorState
}
type CalculatorOption func(*Calculator)

func WithStateChannel(v chan CalculatorState) CalculatorOption {
	return func(c *Calculator) {
		c.StateChannel = v
	}
}

type Calculator struct {
	app                 *runtime.App
	StateChannel        chan CalculatorState
	currentStateChannel CalculatorState
	listenersStarted    bool
}

func NewCalculator(opts ...CalculatorOption) *Calculator {
	c := &Calculator{}
	for _, opt := range opts {
		opt(c)
	}
	if c.StateChannel != nil {
		log("Calculator: About to read initial state from StateChannel")
		c.currentStateChannel = <-c.StateChannel
		log("Calculator: Received initial state from channel")
	}
	return c
}
func (c *Calculator) BindApp(app *runtime.App) {
	log("Calculator: BindApp called")
	c.app = app
	if c.listenersStarted {
		return
	}
	if c.StateChannel != nil {
		c.startStateChannelListener()
	}
	c.listenersStarted = true
}
func (c *Calculator) startStateChannelListener() {
	go func() {
		for val := range c.StateChannel {
			c.currentStateChannel = val
			if c.app != nil {
				c.app.Update()
			}
		}
	}()
}
func (c *Calculator) Render() *runtime.VNode {
	log("Calculator: Render called")
	return func() *runtime.VNode {
		return runtime.Div(runtime.Class("calculator"), runtime.Div(runtime.Class("display"), runtime.Text(fmt.Sprint(c.currentStateChannel.Display))), runtime.Div(runtime.Class("buttons"), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "7")
		}), runtime.Text("7")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "8")
		}), runtime.Text("8")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "9")
		}), runtime.Text("9")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "/")
		}), runtime.Text("÷"))), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "4")
		}), runtime.Text("4")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "5")
		}), runtime.Text("5")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "6")
		}), runtime.Text("6")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "*")
		}), runtime.Text("×"))), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "1")
		}), runtime.Text("1")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "2")
		}), runtime.Text("2")), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "3")
		}), runtime.Text("3")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "-")
		}), runtime.Text("−"))), runtime.Div(runtime.Class("button-row"), runtime.Button(runtime.Class("button number"), runtime.OnClick(func(e runtime.Event) {
			handleNumber(c.StateChannel, c.currentStateChannel, "0")
		}), runtime.Text("0")), runtime.Button(runtime.Class("button clear"), runtime.OnClick(func(e runtime.Event) {
			handleClear(c.StateChannel)
		}), runtime.Text("C")), runtime.Button(runtime.Class("button equals"), runtime.OnClick(func(e runtime.Event) {
			handleEquals(c.StateChannel, c.currentStateChannel)
		}), runtime.Text("=")), runtime.Button(runtime.Class("button operator"), runtime.OnClick(func(e runtime.Event) {
			handleOperator(c.StateChannel, c.currentStateChannel, "+")
		}), runtime.Text("+")))))
	}()
}
func (c *Calculator) Mount(parent js.Value) {
	runtime.Mount(c.Render(), parent)
}
func (c *Calculator) Unmount() {
}
func (c *Calculator) Update() {
	if c.app != nil {
		c.app.Update()
	}
}
func handleNumber(stateChannel chan CalculatorState, state CalculatorState, digit string) {
	if state.JustCalculated {
		state.Expression = digit
		state.Display = digit
		state.JustCalculated = false
	} else {
		state.Expression = state.Expression + digit
		state.Display = state.Expression
	}
	stateChannel <- state
}
func handleOperator(stateChannel chan CalculatorState, state CalculatorState, operator string) {
	if state.JustCalculated {
		state.Expression = formatNumber(state.LastResult) + " " + operator + " "
		state.Display = state.Expression
		state.JustCalculated = false
	} else if state.Expression != "" {
		state.Expression = state.Expression + " " + operator + " "
		state.Display = state.Expression
	}
	stateChannel <- state
}
func handleEquals(stateChannel chan CalculatorState, state CalculatorState) {
	result := evaluateExpr(state.Expression)
	state.Display = formatNumber(result)
	state.LastResult = result
	state.JustCalculated = true
	stateChannel <- state
}
func handleClear(stateChannel chan CalculatorState) {
	stateChannel <- CalculatorState{Display: "0", Expression: "", LastResult: 0, JustCalculated: false}
}
func evaluateExpr(expr string) float64 {
	// Parse and evaluate expression left-to-right
	tokens := strings.Fields(expr)
	if len(tokens) == 0 {
		return 0.0
	}

	// Start with first number
	result, _ := strconv.ParseFloat(tokens[0], 64)

	// Process operator-number pairs
	for i := 1; i < len(tokens)-1; i += 2 {
		operator := tokens[i]
		num, _ := strconv.ParseFloat(tokens[i+1], 64)
		result = calculate(result, num, operator)
	}

	return result
}
func calculate(a float64, b float64, operator string) float64 {
	result := b
	if operator == "+" {
		result = a + b
	} else if operator == "-" {
		result = a - b
	} else if operator == "*" {
		result = a * b
	} else if operator == "/" {
		if b != 0 {
			result = a / b
		} else {
			result = 0
		}
	}
	return result
}
func formatNumber(num float64) string {
	return fmt.Sprintf("%g", num)
}
func NewCalculatorStateChannel() chan CalculatorState {
	ch := make(chan CalculatorState, 10)
	ch <- CalculatorState{Display: "0", Expression: "", LastResult: 0, JustCalculated: false}
	return ch
}
