package main

import "fmt"
import "strconv"
import "strings"

type CalculatorState struct {
	Tokens         []string // Slice of tokens (e.g., ["2", "+", "3"])
	CurrentInput   string   // Current number being typed
	JustCalculated bool     // True if we just pressed "="
	LastResult     float64  // Last calculated result
}

@props func Calculator(stateChannel chan CalculatorState) (Component) {
	currentState := <-stateChannel

	Div(Class("calculator")) {
		Div(Class("display")) {
			`{buildDisplay(currentState)}`
		}
		Div(Class("buttons")) {
			Div(Class("button-row")) {
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "7")
				})) {
					"7"
				}
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "8")
				})) {
					"8"
				}
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "9")
				})) {
					"9"
				}
				Button(Class("button operator"), OnClick(func(e Event) {
					handleOperator(stateChannel, currentState, "/")
				})) {
					"÷"
				}
			}
			Div(Class("button-row")) {
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "4")
				})) {
					"4"
				}
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "5")
				})) {
					"5"
				}
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "6")
				})) {
					"6"
				}
				Button(Class("button operator"), OnClick(func(e Event) {
					handleOperator(stateChannel, currentState, "*")
				})) {
					"×"
				}
			}
			Div(Class("button-row")) {
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "1")
				})) {
					"1"
				}
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "2")
				})) {
					"2"
				}
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "3")
				})) {
					"3"
				}
				Button(Class("button operator"), OnClick(func(e Event) {
					handleOperator(stateChannel, currentState, "-")
				})) {
					"−"
				}
			}
			Div(Class("button-row")) {
				Button(Class("button number"), OnClick(func(e Event) {
					handleNumber(stateChannel, currentState, "0")
				})) {
					"0"
				}
				Button(Class("button clear"), OnClick(func(e Event) {
					handleClear(stateChannel)
				})) {
					"C"
				}
				Button(Class("button equals"), OnClick(func(e Event) {
					handleEquals(stateChannel, currentState)
				})) {
					"="
				}
				Button(Class("button operator"), OnClick(func(e Event) {
					handleOperator(stateChannel, currentState, "+")
				})) {
					"+"
				}
			}
		}
	}
}

func handleNumber(stateChannel chan CalculatorState, state CalculatorState, digit string) {
	// If we just calculated, start fresh
	if state.JustCalculated {
		state.Tokens = nil
		state.CurrentInput = digit
		state.JustCalculated = false
	} else {
		// Append digit to current input
		state.CurrentInput = state.CurrentInput + digit
	}

	stateChannel <- state
}

func handleOperator(stateChannel chan CalculatorState, state CalculatorState, operator string) {
	// If we just calculated, use the last result to continue
	if state.JustCalculated {
		state.Tokens = nil
		state.Tokens = appendToken(state.Tokens, formatNumber(state.LastResult))
		state.Tokens = appendToken(state.Tokens, operator)
		state.CurrentInput = ""
		state.JustCalculated = false
	} else if state.CurrentInput != "" {
		// Add current input and operator to tokens
		state.Tokens = appendToken(state.Tokens, state.CurrentInput)
		state.Tokens = appendToken(state.Tokens, operator)
		state.CurrentInput = ""
	}

	stateChannel <- state
}

func handleEquals(stateChannel chan CalculatorState, state CalculatorState) {
	// Complete the tokens with current input
	fullTokens := state.Tokens
	if state.CurrentInput != "" {
		fullTokens = appendToken(fullTokens, state.CurrentInput)
	}

	// Calculate result from tokens
	result := calculateFromTokens(fullTokens)

	// Clear and store result
	state.Tokens = nil
	state.CurrentInput = ""
	state.LastResult = result
	state.JustCalculated = true

	stateChannel <- state
}

func handleClear(stateChannel chan CalculatorState) {
	stateChannel <- CalculatorState{
		Tokens:         nil,
		CurrentInput:   "",
		JustCalculated: false,
		LastResult:     0,
	}
}

func buildDisplay(state CalculatorState) (string) {
	// If we just calculated, show the result
	if state.JustCalculated {
		return formatNumber(state.LastResult)
	}

	// Build display from tokens and current input
	display := tokensToString(state.Tokens)

	// Add current input if any
	if state.CurrentInput != "" {
		if display != "" {
			display = display + " " + state.CurrentInput
		} else {
			display = state.CurrentInput
		}
	}

	// If display is empty, show "0"
	if display == "" {
		display = "0"
	}

	return display
}

// Helper functions

// appendToken appends a token to a slice of tokens
func appendToken(tokens []string, token string) ([]string) {
	return append(tokens, token)
}

// tokensToString converts a slice of tokens to a display string
func tokensToString(tokens []string) (string) {
	return strings.Join(tokens, " ")
}

// calculateFromTokens evaluates a slice of tokens with proper operator precedence
func calculateFromTokens(tokens []string) (float64) {
	// Handle empty case
	if len(tokens) == 0 {
		return 0
	}

	// Handle single number
	if len(tokens) == 1 {
		result, _ := strconv.ParseFloat(tokens[0], 64)
		return result
	}

	// Make a copy of tokens to work with
	workingTokens := make([]string, len(tokens))
	copy(workingTokens, tokens)

	// First pass: handle * and / (higher precedence)
	for i := 1; i < len(workingTokens); i += 0 {
		if i+1 < len(workingTokens) {
			operator := workingTokens[i]
			if (operator == "*") || (operator == "/") {
				// Get left and right operands
				left, _ := strconv.ParseFloat(workingTokens[i-1], 64)
				right, _ := strconv.ParseFloat(workingTokens[i+1], 64)

				// Calculate result
				result := calculate(left, right, operator)

				// Replace the three tokens (num op num) with the result
				resultStr := formatNumber(result)

				// Build new slice manually
				newLen := len(workingTokens) - 2
				newTokens := make([]string, newLen)
				// Copy tokens before the operation
				for j := 0; j < (i-1); j += 1 {
					newTokens[j] = workingTokens[j]
				}
				// Add result
				newTokens[i-1] = resultStr
				// Copy tokens after the operation
				for j := i+2; j < len(workingTokens); j += 1 {
					newTokens[j-2] = workingTokens[j]
				}
				workingTokens = newTokens
			} else {
				i = i + 2
			}
		} else {
			i = i + 2
		}
	}

	// Second pass: handle + and - (lower precedence)
	for i := 1; i < len(workingTokens); i += 0 {
		if i+1 < len(workingTokens) {
			operator := workingTokens[i]
			if (operator == "+") || (operator == "-") {
				// Get left and right operands
				left, _ := strconv.ParseFloat(workingTokens[i-1], 64)
				right, _ := strconv.ParseFloat(workingTokens[i+1], 64)

				// Calculate result
				result := calculate(left, right, operator)

				// Replace the three tokens with the result
				resultStr := formatNumber(result)

				// Build new slice manually
				newLen := len(workingTokens) - 2
				newTokens := make([]string, newLen)
				// Copy tokens before the operation
				for j := 0; j < (i-1); j += 1 {
					newTokens[j] = workingTokens[j]
				}
				// Add result
				newTokens[i-1] = resultStr
				// Copy tokens after the operation
				for j := i+2; j < len(workingTokens); j += 1 {
					newTokens[j-2] = workingTokens[j]
				}
				workingTokens = newTokens
			} else {
				i = i + 2
			}
		} else {
			i = i + 2
		}
	}

	// Parse final result
	result, _ := strconv.ParseFloat(workingTokens[0], 64)
	return result
}

// calculate performs a single operation
func calculate(a float64, b float64, operator string) (float64) {
	result := b
	if operator == "+" {
		result = a + b
	} else if operator == "-" {
		result = a - b
	} else if operator == "*" {
		result = a * b
	} else if operator == "/" {
		if b != 0 {
			result = a / b
		} else {
			result = 0
		}
	}
	return result
}

// formatNumber formats a float64 for display
func formatNumber(num float64) (string) {
	return fmt.Sprintf("%g", num)
}

func NewCalculatorStateChannel() (chan CalculatorState) {
	ch := make(chan CalculatorState, 10)
	ch <- CalculatorState{
		Tokens:         nil,
		CurrentInput:   "",
		JustCalculated: false,
		LastResult:     0,
	}
	return ch
}
